// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package token

pub struct Token {
	kind TokenKind
	val string
	pos Pos
}

pub enum TokenKind {
	eof
	name
	string
	char
	number
	dot
	colon
	comma
	semicolon
	plus
	minus
	mul
	div
	mod
	assign
	decl_assign
	plus_assign
	minus_assign
	mul_assign
	div_assign
	mod_assign
	eq
	ne
	lt
	gt
	le
	ge
	lpar
	rpar
	lbr
	rbr
	lcur
	rcur
	pipe
	dollar
	hash
	key_and
	key_as
	key_break
	key_const
	key_continue
	key_else
	key_enum
	key_false
	key_for
	key_fun
	key_global
	key_if
	key_import
	key_in
	key_is
	key_match
	key_mut
	key_not
	key_or
	key_package
	key_pub
	key_return
	key_struct
	key_true
	key_type
	key_typeof
}

pub fun keyword_to_kind(name string) TokenKind {
	match name {
		'and' { return TokenKind.key_and }
		'as' { return TokenKind.key_as }
		'break' { return TokenKind.key_break }
		'const' { return TokenKind.key_const }
		'continue' { return TokenKind.key_continue }
		'else' { return TokenKind.key_else }
		'enum' { return TokenKind.key_enum }
		'false' { return TokenKind.key_false }
		'for' { return TokenKind.key_for }
		'fun' { return TokenKind.key_fun }
		'global' { return TokenKind.key_global }
		'if' { return TokenKind.key_if }
		'import' { return TokenKind.key_import }
		'in' { return TokenKind.key_in }
		'is' { return TokenKind.key_is }
		'match' { return TokenKind.key_match }
		'mut' { return TokenKind.key_mut }
		'not' { return TokenKind.key_not }
		'or' { return TokenKind.key_or }
		'package' { return TokenKind.key_package }
		'pub' { return TokenKind.key_pub }
		'return' { return TokenKind.key_return }
		'struct' { return TokenKind.key_struct }
		'true' { return TokenKind.key_true }
		'type' { return TokenKind.key_type }
		'typeof' { return TokenKind.key_typeof }
		else { return TokenKind.name }
	}
}

const COMPARE_KINDS := [TokenKind.eq, TokenKind.ne, TokenKind.lt, TokenKind.gt, TokenKind.le, TokenKind.ge, TokenKind.key_is]
const MATH_KINDS := [TokenKind.plus, TokenKind.minus, TokenKind.mul, TokenKind.div, TokenKind.mod]
const OTHER_INFIXES := [TokenKind.key_and, TokenKind.key_or]

pub fun (kind TokenKind) is_compare() bool {
	return COMPARE_KINDS.contains(kind)
}

pub fun (kind TokenKind) is_infix() bool {
	return kind.is_compare() or MATH_KINDS.contains(kind) or OTHER_INFIXES.contains(kind)
}

const ASSIGN_KINDS := [TokenKind.decl_assign, TokenKind.assign, TokenKind.plus_assign, TokenKind.minus_assign, TokenKind.mul_assign, TokenKind.div_assign, TokenKind.mod_assign]

pub fun (kind TokenKind) is_assign() bool {
	return ASSIGN_KINDS.contains(kind)
}

pub fun (kind TokenKind) js_repr() string {
	match kind {
		TokenKind.key_break {
			return "break"
		}
		TokenKind.key_continue {
			return "continue"
		}
		TokenKind.key_is {
			return "instanceof"
		}
		TokenKind.mul {
			return "*"
		}
		TokenKind.div {
			return "/"
		}
		TokenKind.mod {
			return "%"
		}
		TokenKind.plus {
			return "+"
		}
		TokenKind.minus {
			return "-"
		}
		TokenKind.mul_assign {
			return "*="
		}
		TokenKind.div_assign {
			return "/="
		}
		TokenKind.mod_assign {
			return "%="
		}
		TokenKind.plus_assign {
			return "+="
		}
		TokenKind.minus_assign {
			return "-="
		}
		TokenKind.decl_assign, TokenKind.assign {
			return "="
		}
		TokenKind.eq {
			return "=="
		}
		TokenKind.ne {
			return "!="
		}
		TokenKind.lt {
			return "<"
		}
		TokenKind.gt {
			return ">"
		}
		TokenKind.le {
			return "<="
		}
		TokenKind.ge {
			return ">="
		}
		TokenKind.key_and {
			return "&&"
		}
		TokenKind.key_not {
			return "!"
		}
		TokenKind.key_or {
			return "||"
		}
	}
}

pub fun (kind TokenKind) str() string {
	match kind {
		TokenKind.eof { return 'eof' }
		TokenKind.name { return 'name' }
		TokenKind.string { return 'string' }
		TokenKind.char { return 'char' }
		TokenKind.number { return 'number' }
		TokenKind.dot { return 'dot' }
		TokenKind.colon { return 'colon' }
		TokenKind.comma { return 'comma' }
		TokenKind.semicolon { return 'semicolon' }
		TokenKind.plus { return 'plus' }
		TokenKind.minus { return 'minus' }
		TokenKind.mul { return 'mul' }
		TokenKind.div { return 'div' }
		TokenKind.mod { return 'mod' }
		TokenKind.assign { return 'assign' }
		TokenKind.decl_assign { return 'decl_assign' }
		TokenKind.plus_assign { return 'plus_assign' }
		TokenKind.minus_assign { return 'minus_assign' }
		TokenKind.mul_assign { return 'mul_assign' }
		TokenKind.div_assign { return 'div_assign' }
		TokenKind.mod_assign { return 'mod_assign' }
		TokenKind.eq { return 'eq' }
		TokenKind.ne { return 'ne' }
		TokenKind.lt { return 'lt' }
		TokenKind.gt { return 'gt' }
		TokenKind.le { return 'le' }
		TokenKind.ge { return 'ge' }
		TokenKind.lpar { return 'lpar' }
		TokenKind.rpar { return 'rpar' }
		TokenKind.lbr { return 'lbr' }
		TokenKind.rbr { return 'rbr' }
		TokenKind.lcur { return 'lcur' }
		TokenKind.rcur { return 'rcur' }
		TokenKind.pipe { return 'pipe' }
		TokenKind.dollar { return 'dollar' }
		TokenKind.hash { return 'hash' }
		TokenKind.key_and { return 'key_and' }
		TokenKind.key_as { return 'key_as' }
		TokenKind.key_break { return 'key_break' }
		TokenKind.key_const { return 'key_const' }
		TokenKind.key_continue { return 'key_continue' }
		TokenKind.key_else { return 'key_else' }
		TokenKind.key_enum { return 'key_enum' }
		TokenKind.key_false { return 'key_false' }
		TokenKind.key_for { return 'key_for' }
		TokenKind.key_fun { return 'key_fun' }
		TokenKind.key_global { return 'key_global' }
		TokenKind.key_if { return 'key_if' }
		TokenKind.key_import { return 'key_import' }
		TokenKind.key_in { return 'key_in' }
		TokenKind.key_is { return 'key_is' }
		TokenKind.key_match { return 'key_match' }
		TokenKind.key_mut { return 'key_mut' }
		TokenKind.key_not { return 'key_not' }
		TokenKind.key_or { return 'key_or' }
		TokenKind.key_package { return 'key_package' }
		TokenKind.key_pub { return 'key_pub' }
		TokenKind.key_return { return 'key_return' }
		TokenKind.key_struct { return 'key_struct' }
		TokenKind.key_true { return 'key_true' }
		TokenKind.key_type { return 'key_type' }
		TokenKind.key_typeof { return 'key_typeof' }
	}
}
