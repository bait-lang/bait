// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package js

import bait.ast
import bait.errors

fun (mut g Gen) get_str_fun(typ ast.Type) string {
	g.needed_str_funs.push(typ)
	sym := g.table.get_sym(typ)
	return js_name('${sym.name}_str')
}

fun (mut g Gen) generate_str_fun(typ ast.Type) {
	sym := g.table.get_sym(typ)
	name := js_name('${sym.name}_str')
	if g.generated_str_funs.contains(typ) {
		return
	}

	str_def := g.table.get_method(sym, 'str')
	if str_def.name.length > 0 {
		return
	}

	if sym.kind == .array {
		info := sym.info as ast.ArrayInfo
		el_str := g.get_str_fun(info.elem_type)

		g.fun_decls_out += 'function ${name}(a) {
	let s = "["
	for (let i = 0; i < a.length; i++) {
		s += ${el_str}(a.data[i]).str
		if (i < a.length - 1) {
			s += ", "
		}
	}
	return from_js_string(s + "]")
}\n'
		return
	}

	// TODO fix indent
	if sym.kind == .struct_ {
		info := sym.info as ast.StructInfo
		g.fun_decls_out += 'function ${name}(it) {
let s = "${sym.name}{"\n'
		if info.fields.length > 0 {
			g.fun_decls_out += 's += "\\n"\n'
		}
		for field in info.fields {
			str_fun_name := g.get_str_fun(field.typ)
			g.fun_decls_out += 's += "    ${field.name}: " + ${str_fun_name}(it.${field.name}).str + "\\n"\n'
		}
		g.fun_decls_out += 'return from_js_string(s + "}")
}\n'
		return
	}

	if sym.kind == .map {
		info := sym.info as ast.MapInfo
		val_str := g.get_str_fun(info.val_type)

		g.fun_decls_out += 'function ${name}(m) {
	let s = "{"
	let i = 0
	for (const [k, v] of m.data.entries()) {
		s += `\'\${k}\'`
		s += ": "
		s += ${val_str}(v).str

		i++
		if (i < m.length) {
			s += ", "
		}
	}
	return from_js_string(s + "}")
}\n'
		return
	}

	errors.generic_error('cannot convert ${sym.name} to string')
	// exit(1)
	return
}
