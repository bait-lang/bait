// Copyright (c) 2023-present Lukas Neubert.
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package js

import bait.preference
import bait.ast
import bait.errors
import bait.token

// Reserved keywords, disallowed identifiers in strict mode and contextual keywords
// See https://tc39.es/ecma262/multipage/ecmascript-language-lexical-grammar.html#sec-keywords-and-reserved-words
const JS_RESERVED := ['await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', 'let', 'static', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'as', 'async', 'from', 'get', 'meta', 'of', 'set', 'target']

struct Gen {
	pref preference.Prefs
	table ast.Table
mut:
	path string
	pkg string
	type_defs_out string
	global_out string
	out string
	indent i32
	empty_line bool
	foreign_imports map[string]string // alias: name
	tmp_counter i32
	cur_concrete_types map[string]ast.Type
	cur_fun ast.FunDecl
	is_for_loop_head bool
	is_lhs_assign bool
	is_array_map_set bool
}

pub fun gen(files []ast.File, table ast.Table, pref preference.Prefs) string {
	mut g := Gen{
		pref = pref
		table = table
		indent = -1
		empty_line = true
		tmp_counter = -1
	}
	for file in files {
		g.path = file.path
		g.pkg = file.pkg_decl.full_name
		g.process_imports(file.imports)
		g.stmts(file.stmts)
		g.out += "\n"
	}
	if pref.is_test {
		g.gen_test_main()
	}
	if not pref.is_library {
		g.main_call()
	}
	headers := g.headers()
	return headers + g.type_defs_out + g.global_out + '\n' + g.out
}

fun (mut g Gen) process_imports(imports []ast.Import) {
	for imp in imports {
		// TODO handle alias clash
		if imp.lang == .bait or g.foreign_imports.contains(imp.alias) {
			continue
		}
		g.foreign_imports[imp.alias] = imp.name
	}
}

fun (g Gen) headers() string {
	mut headers := 'const JS = {}\n'
	for alias, name in g.foreign_imports {
		headers += '${alias} = require("${name}")\n'
	}
	return headers + '\n'
}

fun (mut g Gen) new_temp_var() string {
	g.tmp_counter += 1
	return '_t${g.tmp_counter}'
}

fun (mut g Gen) write_indent() {
	if g.indent > 0 and g.empty_line {
		g.out += '\t'.repeat(g.indent)
	}
}

fun (mut g Gen) write(s string){
	g.write_indent()
	g.out += s
	g.empty_line = false
}

fun (mut g Gen) writeln (s string){
	g.write_indent()
	g.out += s + "\n"
	g.empty_line = true
}

fun (mut g Gen) gen_test_main() {
	mut nr_test_funs := 0
	g.writeln('function main() {')
	g.indent += 1
	for key, func in g.table.fun_decls {
		if func.is_test {
			nr_test_funs += 1
			name := js_name(func.name)
			esc_path := g.path.replace('\\', '\\\\')
			g.writeln('builtin__testing__TestRunner_set_test_info(builtin__testing__test_runner, from_js_string("${esc_path}"), from_js_string("${name}"))')
			g.writeln('${name}()')
		}
	}
	g.writeln('exit(builtin__testing__TestRunner_exit_code(builtin__testing__test_runner))')
	g.indent -= 1
	g.writeln('}')

	if nr_test_funs == 0 {
		errors.generic_error('${g.path} contains no tests')
		exit(1)
	}
}

fun (mut g Gen) main_call() {
	g.out += "main()"
}

fun (mut g Gen) write_default_value(typ ast.Type) {
	match typ {
		ast.I8_TYPE, ast.I16_TYPE, ast.I32_TYPE, ast.I64_TYPE,
		ast.U8_TYPE, ast.U16_TYPE, ast.U32_TYPE, ast.U64_TYPE {
			g.write('0')
		}
		ast.F32_TYPE, ast.F64_TYPE {
			g.write('0.0')
		}
		ast.BOOL_TYPE {
			g.write('false')
		}
		ast.STRING_TYPE {
			g.write('from_js_string("")')
		}
		else {
			sym := g.table.get_sym(typ)
			if sym.kind == .array {
				g.array_init(ast.ArrayInit{
					exprs = []ast.Expr
				})
			} else if sym.kind == .map {
				g.map_init(ast.MapInit{
					keys = []ast.Expr
				})
			} else if sym.kind == .struct_ {
				g.write('new ${js_name(sym.name)}({})')
			} else if sym.kind == .alias_type {
				g.write_default_value(sym.parent)
			} else if sym.kind == .enum_ {
				g.write('0')
			} else {
				g.write('undefined')
			}
		}
	}
}

fun (g Gen) concrete_sym(typ ast.Type) ast.TypeSymbol {
	sym := g.table.get_sym(typ)
	if g.cur_concrete_types.length == 0 {
		return sym
	}

	return g.table.get_sym(g.cur_concrete_types[sym.name])
}

fun js_name(n string) string {
	name := n.replace('.', '__').replace('[]', 'array_')
	if JS_RESERVED.contains(name) {
		return 'bait_${name}'
	}
	return name
}
