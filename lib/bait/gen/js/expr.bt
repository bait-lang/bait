// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package js

import bait.ast
import bait.token
import bait.util
import os

fun (g Gen) expr(expr ast.Expr) {
	if expr is ast.AnonFun {
		g.anon_fun(expr)
	} else if expr is ast.ArrayInit {
		g.array_init(expr)
	} else if expr is ast.AsCast {
		g.as_cast(expr)
	} else if expr is ast.BoolLiteral {
		g.bool_literal(expr)
	} else if expr is ast.CallExpr {
		g.call_expr(expr)
	} else if expr is ast.CharLiteral {
		g.char_literal(expr)
	} else if expr is ast.CompTimeVar {
		g.comp_time_var(expr)
	} else if expr is ast.EnumVal {
		g.enum_val(expr)
	} else if expr is ast.HashExpr {
		g.hash_expr(expr)
	} else if expr is ast.Ident {
		g.ident(expr)
	} else if expr is ast.IfExpr {
		g.if_expr(expr)
	} else if expr is ast.IndexExpr {
		g.index_expr(expr)
	} else if expr is ast.InfixExpr {
		g.infix_expr(expr)
	} else if expr is ast.IntegerLiteral {
		g.integer_literal(expr)
	} else if expr is ast.MapInit {
		g.map_init(expr)
	} else if expr is ast.MatchExpr {
		g.match_expr(expr)
	} else if expr is ast.ParExpr {
		g.par_expr(expr)
	} else if expr is ast.PrefixExpr {
		g.prefix_expr(expr)
	} else if expr is ast.SelectorExpr {
		g.selector_expr(expr)
	} else if expr is ast.StringLiteral {
		g.string_literal(expr)
	} else if expr is ast.StringInterLiteral {
		g.string_inter_literal(expr)
	} else if expr is ast.StructInit {
		g.struct_init(expr)
	} else if expr is ast.TypeOf {
		g.type_of(expr)
	} else {}
}

fun (g Gen) expr_string(expr ast.Expr) string {
	was_line_empty := g.empty_line
	start := g.out.length
	g.expr(expr)
	s := g.out.substr(start, g.out.length)
	g.out = g.out.substr(0, start)
	g.empty_line = was_line_empty
	return s.trim_space()
}

fun (g Gen) anon_fun(node ast.AnonFun) {
	g.write('function (')
	for i, param in node.decl.params {
		g.write(param.name)
		if i < node.decl.params.length - 1 {
			g.write(', ')
		}
	}
	g.writeln(') {')
	g.stmts(node.decl.stmts)
	g.write('}')
}

fun (g Gen) array_init(node ast.ArrayInit) {
	g.write('new array({ data: [')
	for i, expr in node.exprs {
		g.expr(expr)
		if i < node.exprs.length - 1 {
			g.write(', ')
		}
	}
	g.write('], length: ${node.exprs.length} })')
}

fun (g Gen) as_cast(node ast.AsCast) {
	target_sym := g.table.get_sym(node.target)
	if target_sym.kind == .alias_type {
		// g.write('new ${js_name(target_sym.name)}(')
		g.expr(node.expr)
		// g.write(')')
		return
	}

	g.expr(node.expr)
}

fun (g Gen) bool_literal(node ast.BoolLiteral){
	if node.val {
		g.write('true')
	} else {
		g.write('false')
	}
}

fun (g Gen) call_expr(node ast.CallExpr) {
	if node.is_method and node.lang != .bait {
		g.expr(node.left)
		g.write('.' + node.name + '(')
		g.call_args(node.args)
		g.write(')')
		return
	}

	if node.is_method {
		sym := g.table.get_sym(node.left_type)
		g.write(js_name(sym.name + '_' + node.name))
	} else {
		g.write(js_name(node.name))
	}
	if ['println', 'eprintln'].contains(node.name) {
		g.write('(')
		g.expr_to_string(node.args[0].expr, node.args[0].typ)
		g.write(')')
		return
	}
	g.write('(')
	if node.is_method {
		g.expr(node.left)
		if node.args.length > 0 {
			g.write(', ')
		}
	}
	g.call_args(node.args)
	g.write(')')
}

fun (g Gen) call_args(args []ast.CallArg) {
	for i, a in args {
		g.expr(a.expr)
		if i < args.length - 1 {
			g.write(", ")
		}
	}
}

fun (g Gen) char_literal(node ast.CharLiteral) {
	g.write('new u8("')
	g.write(util.escape_char(node.val, `\"`))
	g.write('")')
}

fun (g Gen) comp_time_var(node ast.CompTimeVar){
	g.write('from_js_string("')
	match node.name{
		'PKG' {g.write(g.pkg)}
		'FILE' {g.write(g.path)}
		'ABS_FILE' {g.write(os.abs_path(g.path))}
		'LINE' {g.write('${node.pos.line}')}
		'FILE_LINE' {g.write('${g.path}:${node.pos.line}')}
		'FUN' {g.write(g.cur_fun.name)}
		'BAITEXE' {g.write(g.pref.baitexe)}
		'BAITDIR' {g.write(g.pref.baitdir)}
		'BAITHASH' {g.write(g.pref.baithash)}
	}
	g.write('")')
}

fun (g Gen) enum_val(node ast.EnumVal) {
	g.write(js_name(node.name) + '.' + node.val)
}

fun (g Gen) hash_expr(node ast.HashExpr) {
	g.write(node.val)
}

fun (g Gen) ident(node ast.Ident) {
	g.write(js_name(node.name))
}

fun (g Gen) if_expr(node ast.IfExpr){
	for i, b in node.branches {
		if i > 0 {
			g.write("} else ")
		}
		if node.has_else and i == node.branches.length - 1 {
			g.writeln("{")
		} else {
			g.write("if (")
			g.expr(b.cond)
			g.writeln(") {")
		}
		g.stmts(b.stmts)
	}
	g.writeln('}')
}

fun (g Gen) integer_literal(node ast.IntegerLiteral){
	g.write(node.val)
}

fun (g Gen) index_expr(node ast.IndexExpr){
	sym := g.table.get_sym(node.left_type)
	if sym.kind == .map {
		if g.is_lhs_assign and not node.is_selector {
			g.is_array_map_set = true
			g.write('map_set(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.index)
			g.write(', ')
		} else {
			g.write('map_get_set(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.index)
			g.write(', ')
			info := sym.info as ast.MapInfo
			g.write_default_value(info.val_type)
			g.write(')')
		}
		return
	}

	if sym.kind == .array {
		if g.is_lhs_assign and not node.is_selector {
			g.is_array_map_set = true
			g.write('array_set(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.index)
			g.write(', ')
		} else {
			g.write('array_get(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.index)
			g.write(')')
		}
		return
	}

	if sym.kind == .string {
		g.write('string_get(')
		g.expr(node.left)
		g.write(', ')
		g.expr(node.index)
		g.write(')')
		return
	}

	// TODO should this even be reachable?
	g.expr(node.left)
	g.write('[')
	g.expr(node.index)
	g.write(']')
}

fun (g Gen) infix_expr(node ast.InfixExpr){
	// TODO should overloading be recursive like methods too?
	lsym := g.table.get_sym(node.left_type)
	if lsym.overloads.contains(node.op.js_repr()) {
		overload := lsym.overloads[node.op.js_repr()]
		g.write(js_name(lsym.name + '_' + overload.name))
		g.write('(')
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
		return
	}

	// Use builtin deep equal function
	if node.op == .eq or node.op == .ne {
		if node.op == .ne {
			g.write('!')
		}
		g.write('eq(')
		g.expr(node.left)
		g.write(', ')
		g.expr(node.right)
		g.write(')')
		return
	}

	// U8 special cases
	// TODO replace with overloading
	if node.left_type == ast.U8_TYPE {
		if node.op == .plus {
			g.write('u8_add(')
			g.expr(node.left)
			g.write(', ')
			g.expr(node.right)
			g.write(')')
			return
		}
		g.expr(node.left)
		g.write('.val ')
		g.write(node.op.js_repr())
		g.write(' ')
		g.expr(node.right)
		g.write('.val')
		return
	}

	// Normal cases
	g.expr(node.left)
	g.write(' ')
	g.write(node.op.js_repr())
	g.write(' ')
	g.expr(node.right)
}

fun (g Gen) map_init(node ast.MapInit) {
	g.write('new map({ data: new Map([')
	for i, key in node.keys {
		g.write('[')
		g.expr_to_string(key, node.key_type)
		g.write(', ')
		g.expr(node.vals[i])
		g.write(']')
		if i < node.keys.length - 1 {
			g.write(', ')
		}
	}
	g.write(']), length: ${node.keys.length} })')
}

fun (g Gen) match_expr(node ast.MatchExpr){
	if node.is_sumtype {
		g.sumtype_match(node)
		return
	}
	g.write('switch (')
	g.expr(node.cond)
	if node.cond_type == ast.STRING_TYPE {
		g.write('.str')
	} else if node.cond_type == ast.U8_TYPE {
		g.write('.val')
	}
	g.writeln(') {')
	g.indent += 1
	for b in node.branches {
		if b.exprs.length == 0 {
			g.writeln("default:")
		} else {
			for i, e in b.exprs {
				g.write("case ")
				if node.cond_type == ast.STRING_TYPE {
					g.expr_to_string(e, b.expr_types[i])
				} else if node.cond_type == ast.U8_TYPE {
					g.expr(e)
					g.write('.val')
				} else {
					g.expr(e)
				}
				g.writeln(":")
			}
		}
		g.indent += 1
		g.writeln("{")
		g.stmts(b.stmts)
		g.writeln("\tbreak")
		g.writeln("}")
		g.indent -= 1
	}
	g.indent -= 1
	g.writeln('}')
}

fun (g Gen) sumtype_match(node ast.MatchExpr){
	cond := g.expr_string(node.cond)
	for i, b in node.branches {
		if i >= 1 {
			g.write("} else ")
		}
		if b.exprs.length == 0 {
			g.writeln("{")
		} else {
			g.write("if (")
			for j, e in b.exprs {
				expr := e as ast.Ident
				g.write("${cond} instanceof ${js_name(expr.name)}")
				if j < b.exprs.length - 1 {
					g.write(" || ")
				}
			}
			g.writeln(") {")
		}
		g.stmts(b.stmts)
	}
	g.writeln('}')
}

fun (g Gen) par_expr(node ast.ParExpr){
	g.write('(')
	g.expr(node.expr)
	g.write(')')
}

fun (g Gen) prefix_expr(node ast.PrefixExpr){
	g.write(node.op.js_repr())
	if node.right is ast.InfixExpr and (node.right as ast.InfixExpr).op == .key_is {
		g.write('(')
		g.expr(node.right)
		g.write(')')
		return
	}
	g.expr(node.right)
}

fun (g Gen) selector_expr(node ast.SelectorExpr) {
	g.expr(node.expr)
	g.write('.')
	g.write(node.field_name)
}

fun (g Gen) string_literal(node ast.StringLiteral) {
	val := util.escape_char(node.val.replace('\n', '\\n'), `\"`)
	g.write('from_js_string("')
	g.write(val)
	g.write('")')
}

fun (g Gen) string_inter_literal(node ast.StringInterLiteral) {
	g.write('from_js_string(`')
	for i, val in node.vals {
		g.write(util.escape_char(val, `\``))
		if i < node.exprs.length {
			g.write('\${')
			g.expr_to_string(node.exprs[i], node.expr_types[i])
			g.write('}')
		}
	}
	g.write('`)')
}

fun (g Gen) struct_init(node ast.StructInit) {
	g.write('new ' + js_name(node.name) + '({')
	if node.fields.length == 0 {
		g.write('})')
		return
	}
	g.write(' ')
	for i, field in node.fields {
		g.write('${field.name}: ')
		g.expr(field.expr)
		if i < node.fields.length - 1 {
			g.write(', ')
		}
	}
	g.write(' })')
}

fun (g Gen) type_of(node ast.TypeOf) {
	sym := g.table.get_sym(node.typ)
	g.write('from_js_string("' + sym.name + '")')
}

fun (g Gen) expr_to_string(expr ast.Expr, typ ast.Type) {
	sym := g.table.get_sym(typ)
	if sym.kind == .string {
		g.expr(expr)
		g.write('.str')
	} else if g.table.get_method(sym, 'str').name.length > 0 {
		mut name := js_name(sym.name)
		if sym.kind == .array {
			name = 'array'
		}
		g.write('${name}_str(')
		g.expr(expr)
		g.write(')')
	} else {
		g.expr(expr)
		g.write('.toString()')
	}
}
