// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package checker

import bait.ast

fun (mut c Checker) if_match(mut node ast.IfMatch) ast.Type {
	save_is_if_match_expr := c.is_if_match_expr

	// Nested if/match expr. The parser does not have this information
	if c.is_if_match_expr {
		node.is_expr = true
	}

	if node.is_expr {
		c.is_if_match_expr = true
		node.typ = c.expected_type
	}

	mut cond_sym := ast.TypeSymbol{}
	if node.is_match {
		// Check at least one branch except `else` exists
		min_branches := if node.has_else { 2 } else { 1 }
		if node.branches.length < min_branches {
			c.error('match needs at least one non-else branch', node.pos)
			return ast.PLACEHOLDER_TYPE
		}

		// Are we in a sumtype match?
		cond_type := c.expr((node.branches[0].cond as ast.InfixExpr).left)
		cond_sym = c.table.get_sym(cond_type)
		c.is_sumtype_match = cond_sym.kind == .sum_type
	}

	mut branch_exprs := []string
	mut nr_branches_return := 0
	for i, branch in node.branches {
		c.open_scope()

		// Condition
		if not node.has_else or i < node.branches.length - 1 {
			cond_type := c.expr(branch.cond)

			if node.is_match {
				key := (branch.cond as ast.InfixExpr).right.repr()
				if branch_exprs.contains(key) {
					c.error('match case `${key}` is already handled', branch.pos)
				} else {
					branch_exprs.push(key)
				}
			}

			if not c.is_sumtype_match and cond_type != ast.BOOL_TYPE and cond_type != ast.PLACEHOLDER_TYPE {
				c.error('expected bool, got ${c.table.type_name(cond_type)}', node.pos)
			}
		}

		if node.is_expr {
			c.expected_type = node.typ
		}

		c.stmts(branch.stmts)
		c.close_scope()

		if node.is_expr {
			last := branch.stmts.last()
			if is_noreturn_call(last) {
				continue
			}

			if c.stmt_returns(last) {
				nr_branches_return += 1
			} else {
				c.error('branch does not return a value', branch.pos)
				continue
			}

			typ := (last as ast.ExprStmt).typ
			if node.typ == ast.VOID_TYPE {
				node.typ = typ
			} else if not c.check_types(typ, node.typ) {
				c.error('branch returns ${c.table.type_name(typ)}, expected ${c.table.type_name(node.typ)}', branch.pos)
			}
		} else if has_toplevel_return(branch.stmts) {
			nr_branches_return += 1
		}
	}

	// Exhaustive check
	if node.is_match {
		mut is_exhaustive := true
		if cond_sym.info is ast.EnumInfo {
			info := cond_sym.info as ast.EnumInfo
			for val in info.vals {
				if not branch_exprs.contains(val) {
					is_exhaustive = false
				}
			}
		} else if cond_sym.info is ast.SumTypeInfo {
			info := cond_sym.info as ast.SumTypeInfo
			for typ in info.variants {
				variant := c.table.type_name(typ)
				if not branch_exprs.contains(variant) {
					is_exhaustive = false
				}
			}
		} else {
			is_exhaustive = false
		}

		if is_exhaustive {
			if node.has_else {
				c.warn('match is exhaustive, else is unreachable', node.pos)
			}
		} else if not node.has_else {
			// TODO make error
			c.warn('match is not exhaustive (add `else {}` branch)', node.pos)
		}
	}

	c.returns = nr_branches_return == node.branches.length
	c.is_if_match_expr = save_is_if_match_expr
	c.is_sumtype_match = false

	return node.typ
}
