// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package checker

import bait.ast

fun (mut c Checker) if_match(mut node ast.IfMatch, is_expr bool) ast.Type {
	if is_expr {
		c.is_if_match_expr = true
		node.typ = c.expected_type
	}

	mut branch_exprs := []string
	if node.is_match {
		// Check at least one branch except `else` exists
		min_branches := if node.has_else { 2 } else { 1 }
		if node.branches.length < min_branches {
			c.error('match needs at least one non-else branch', node.pos)
			return ast.PLACEHOLDER_TYPE
		}

		// Are we in a sumtype match?
		cond_type := c.expr((node.branches[0].cond as ast.InfixExpr).left)
		sym := c.table.get_sym(cond_type)
		c.is_sumtype_match = sym.kind == .sum_type
	}

	mut nr_branches_return := 0
	for i, branch in node.branches {
		c.open_scope()

		// Condition
		if not node.has_else or i < node.branches.length - 1 {
			cond_type := c.expr(branch.cond)

			if node.is_match {
				key := (branch.cond as ast.InfixExpr).right.repr()
				if branch_exprs.contains(key) {
					c.error('match case `${key}` is already handled', branch.pos)
				} else {
					branch_exprs.push(key)
				}
			}

			if not c.is_sumtype_match and cond_type != ast.BOOL_TYPE and cond_type != ast.PLACEHOLDER_TYPE {
				c.error('expected bool, got ${c.table.type_name(cond_type)}', node.pos)
			}
		}

		if is_expr {
			c.expected_type = node.typ
		}

		c.stmts(branch.stmts)
		c.close_scope()

		if is_expr {
			last := branch.stmts.last()
			if is_noreturn_call(last) {
				continue
			}

			if not (last is ast.ExprStmt) or (last as ast.ExprStmt).typ == ast.VOID_TYPE {
				c.error('branch does not return a value', branch.pos)
				continue
			}

			typ := (last as ast.ExprStmt).typ
			if node.typ == ast.VOID_TYPE {
				node.typ = typ
			} else if not c.check_types(typ, node.typ) {
				c.error('branch returns ${c.table.type_name(typ)}, expected ${c.table.type_name(node.typ)}', branch.pos)
			}
		} else if has_toplevel_return(branch.stmts) {
			nr_branches_return += 1
		}
	}

	c.returns = nr_branches_return == node.branches.length
	c.is_if_match_expr = false
	c.is_sumtype_match = false
	return node.typ
}
