// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package checker

import bait.ast

fun (mut c Checker) if_expr(mut node ast.IfExpr, is_expr bool) ast.Type {
	if is_expr {
		c.is_if_expr = true
		node.typ = c.cur_fun.return_type
	}

	if node.is_match {
		mut min_branches := 1
		if node.has_else {
			min_branches += 1
		}
		if node.branches.length < min_branches {
			c.error('match expression needs at least one non-else branch', node.pos)
			return ast.PLACEHOLDER_TYPE
		}
	}

	// Are we in a sumtype match?
	if node.is_match {
		cond_type := c.expr((node.branches[0].cond as ast.InfixExpr).left)
		sym := c.table.get_sym(cond_type)
		c.is_sumtype_match = sym.kind == .sum_type
	}

	mut nr_branches_return := 0
	for i, branch in node.branches {
		c.open_scope()
		if not node.has_else or i < node.branches.length - 1 {
			cond_type := c.expr(branch.cond)
			if not c.is_sumtype_match and cond_type != ast.BOOL_TYPE and cond_type != ast.PLACEHOLDER_TYPE {
				c.error('expected bool, got ${c.table.type_name(cond_type)}', node.pos)
			}
		}

		if is_expr {
			c.expected_type = node.typ
		}

		c.stmts(branch.stmts)
		c.close_scope()

		if is_expr {
			last := branch.stmts.last()
			if not (last is ast.ExprStmt) or (last as ast.ExprStmt).typ == ast.VOID_TYPE {
				c.error('branch does not return a value', branch.pos)
				continue
			}

			typ := (last as ast.ExprStmt).typ
			if node.typ == ast.VOID_TYPE {
				node.typ = typ
			} else if not c.check_types(typ, node.typ) {
				c.error('branch returns ${c.table.type_name(typ)}, expected ${c.table.type_name(node.typ)}', branch.pos)
			}
		} else if has_toplevel_return(branch.stmts) {
			nr_branches_return += 1
		}
	}

	c.returns = nr_branches_return == node.branches.length
	c.is_if_expr = false
	c.is_sumtype_match = false
	return node.typ
}
