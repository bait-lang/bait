// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package checker

import bait.ast
import bait.errors

fun (c Checker) call_expr(node ast.CallExpr) ast.Type {
	if node.is_method{
		return c.method_call(node)
	}
	return c.fun_call(node)
}

fun (c Checker) fun_call(node ast.CallExpr) ast.Type {
	mut found := c.table.fun_decls.contains(node.name)
	if not found and not node.name.contains('.') and node.pkg != 'builtin' {
		full_name := node.pkg + '.' + node.name
		if c.table.fun_decls.contains(full_name) {
			node.name = full_name
			found = true
		}
	}
	if not found {
		obj := c.scope.get(node.name)
		if obj.kind == .function {
			found = true
		}
	}
	if found {
		def := c.table.fun_decls[node.name]
		if not def.is_pub and node.pkg != c.pkg {
			c.error('function ${def.name} is private', node.pos)
		}
		if node.args.length == def.params.length {
			if node.name == 'println' or node.name == 'eprintln' {
				// TODO check arg can be printed
				for arg in node.args {
					arg.typ = c.expr(arg.expr)
				}
				return ast.VOID_TYPE
			}
			for i, arg in node.args {
				param_type := def.params[i].typ
				c.expected_type = param_type
				arg.typ = c.expr(arg.expr)
				if not c.check_types(arg.typ, param_type) {
					c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
				}
			}
		} else {
			c.error('expected ${def.params.length} arguments but got ${node.args.length}', node.pos)
		}
		node.return_type = def.return_type
		c.check_attributes_on_call(node, def)
	} else {
		c.error('unknown function ${node.name}', node.pos)
	}
	return node.return_type
}

fun (c Checker) method_call(node ast.CallExpr) ast.Type {
	left_expr_type := c.expr(node.left)
	left_sym := c.table.get_sym(left_expr_type)
	def := c.table.get_method(left_sym, node.name)
	if def.name.length == 0 {
		c.error('method ${node.name} not found on type ${left_sym.name}', node.pos)
		return ast.VOID_TYPE
	}
	if not def.is_pub and left_sym.pkg != c.pkg {
		c.error('method ${def.name} is private', node.pos)
	}

	// Check argument count and types
	if node.args.length + 1 == def.params.length {
		for i, arg in node.args {
			param_type := def.params[i + 1].typ
			c.expected_type = param_type
			arg.typ = c.expr(arg.expr)
			if not c.check_types(arg.typ, param_type) {
				c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
			}
		}
	} else {
		c.error('expected ${def.params.length - 1} arguments but got ${node.args.length}', node.pos)
	}

	node.lang = def.lang
	node.left_type = def.params[0].typ
	node.return_type = def.return_type
	c.check_attributes_on_call(node, def)
	return node.return_type
}

fun (c Checker) check_attributes_on_call(call ast.CallExpr, def ast.FunDecl) {
	mut is_deprecated := false
	mut depr_attr := ast.Attribute{}
	mut depr_date_attr := ast.Attribute{}

	for attr in def.attrs {
		if attr.name == 'deprecated_after' {
			depr_date_attr = attr
			is_deprecated = true
		}
		if attr.name == 'deprecated' {
			depr_attr = attr
			is_deprecated = true
		}
	}

	if is_deprecated {
		mut depr_message := 'function "${call.name}" '
		if depr_date_attr.name.length > 0 {
			depr_message += 'will be deprecated after ${depr_date_attr.value}'
		} else {
			depr_message += 'is deprecated'
		}
		if depr_attr.value.length > 0 {
			depr_message += '; ${depr_attr.value}'
		}
		errors.notice('note', c.path, call.pos, depr_message)
		// TODO check deprecation date and warn if passed
	}
}
