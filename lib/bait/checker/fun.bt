// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package checker

import bait.ast
import bait.token

fun (mut c Checker) fun_decl(node ast.FunDecl) {
	if node.lang != .bait {
		return
	}

	c.cur_fun = node
	c.check_fun_attrs(node)
	c.open_scope()
	c.fun_params(node.params)
	c.stmts(node.stmts)
	c.close_scope()
}

fun (c Checker) fun_params(params []ast.Param){
	for p in params {
		if c.scope.is_known(p.name) {
			c.error('cannot shadow import "${p.name}"', p.pos)
			continue
		}

		sym := c.table.get_sym(p.typ)
		if sym.kind == .fun_ {
			c.scope.register(p.name, ast.ScopeObject{
				typ = p.typ
				kind = .function
			})
		} else {
			c.scope.register(p.name, ast.ScopeObject{
				typ = p.typ
				is_mut = p.is_mut
			})
		}
	}
}

fun (mut c Checker) check_main_fun(stmts []ast.Stmt) {
	for stmt in stmts {
		if stmt is ast.FunDecl and stmt.name == 'main' {
			c.has_main_fun = true
		}
	}
}

fun (c Checker) call_expr(node ast.CallExpr) ast.Type {
	if node.is_method{
		return c.method_call(node)
	}
	return c.fun_call(node)
}

fun (mut c Checker) fun_call(node ast.CallExpr) ast.Type {
	mut found := c.table.fun_decls.contains(node.name)
	if not found and not node.name.contains('.') and node.pkg != 'builtin' {
		full_name := node.pkg + '.' + node.name
		if c.table.fun_decls.contains(full_name) {
			node.name = full_name
			found = true
		}
	}
	if not found {
		obj := c.scope.get(node.name)
		if obj.kind == .function {
			found = true
		}
	}
	if not found {
		c.error('unknown function ${node.name}', node.pos)
		return ast.VOID_TYPE
	}

	def := c.table.fun_decls[node.name]
	if not def.is_pub and def.pkg != c.pkg {
		c.error('function ${def.name} is private', node.pos)
	}
	node.return_type = def.return_type
	c.check_fun_attrs_on_call(node, def)

	// Check argument count
	if node.args.length != def.params.length {
		c.error('expected ${def.params.length} arguments but got ${node.args.length}', node.pos)
		return node.return_type
	}

	// Handle special builtin functions
	if node.name == 'println' or node.name == 'eprintln' {
		// TODO check arg can be printed
		for arg in node.args {
			arg.typ = c.expr(arg.expr)
		}
		return ast.VOID_TYPE
	}

	// Check argument types
	for i, arg in node.args {
		param_type := def.params[i].typ
		c.expected_type = param_type
		arg.typ = c.expr(arg.expr)
		if arg.typ == ast.VOID_TYPE and not arg.expr is ast.CallExpr {
			// Another error was already raised
			continue
		}
		if not c.check_types(arg.typ, param_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
		}
	}

	return node.return_type
}

fun (mut c Checker) method_call(node ast.CallExpr) ast.Type {
	left_expr_type := c.expr(node.left)
	left_sym := c.table.get_sym(left_expr_type)
	final_sym := c.table.get_final_sym(left_expr_type)
	def := c.table.get_method(left_sym, node.name)
	if def.name.length == 0 {
		c.error('method ${node.name} not found on type ${left_sym.name}', node.pos)
		return ast.VOID_TYPE
	}
	if not def.is_pub and left_sym.pkg != c.pkg {
		c.error('method ${def.name} is private', node.pos)
	}

	node.lang = def.lang
	node.left_type = def.params[0].typ
	if final_sym.kind == .array and ['push', 'push_many_with_len', 'push_many'].contains(node.name) {
		node.left_type = left_expr_type
	}
	node.return_type = def.return_type
	c.check_fun_attrs_on_call(node, def)

	// Check argument count
	if node.args.length + 1 != def.params.length {
		c.error('expected ${def.params.length - 1} arguments but got ${node.args.length}', node.pos)
		return node.return_type
	}

	// Array methods with one argument of `any` type
	if final_sym.kind == .array and ['push', 'push_many_with_len', 'index', 'last_index', 'contains'].contains(node.name) {
		arg := node.args[0]
		info := final_sym.info as ast.ArrayInfo
		c.expected_type = info.elem_type
		arg.typ = c.expr(arg.expr)
		if not c.check_types(arg.typ, info.elem_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(info.elem_type)} in argument 1', node.pos)
		}
		return node.return_type
	}
	// Array methods with one argument of `array` type
	if final_sym.kind == .array and ['concat', 'push_many'].contains(node.name) {
		arg := node.args[0]
		c.expected_type = left_expr_type
		arg.typ = c.expr(arg.expr)
		if not c.check_types(arg.typ, left_expr_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(left_expr_type)} in argument 1', node.pos)
		}
		return node.return_type
	}

	// Check argument types
	for i, arg in node.args {
		param_type := def.params[i + 1].typ
		c.expected_type = param_type
		arg.typ = c.expr(arg.expr)
		if not c.check_types(arg.typ, param_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
		}
	}

	// Array methods with return type `array`
	if left_sym.kind == .array and ['filter', 'reverse', 'slice', 'copy', 'from_js_arr'].contains(node.name) {
		return left_expr_type
	}

	return node.return_type
}
