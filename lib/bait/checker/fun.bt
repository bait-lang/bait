// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package checker

import bait.ast
import bait.token

fun (mut c Checker) fun_decl(node ast.FunDecl) {
	if node.lang != .bait {
		return
	}

	c.returns = false

	if node.is_method {
		sym := c.table.get_sym(node.params[0].typ)
		if sym.info is ast.StructInfo {
			field := sym.find_field(node.name, c.table)
			if field.name.length > 0 {
				if c.table.get_sym(field.typ).kind == .fun_ {
					c.error('struct has a field and method named ${node.name}', node.pos)
				}
			}
		}
	} else {
		if c.scope.is_known(node.name) {
			c.error('redefinition of ${node.name}', node.pos)
		}
		mut param_types := []ast.Type
		for param in node.params {
			param_types.push(param.typ)
		}
		c.scope.register(node.name, ast.ScopeObject{
			typ = c.table.find_or_register_fun(param_types, node.return_type)
			kind = .function
		})
	}

	c.cur_fun = node
	c.check_fun_attrs(node)
	c.open_scope()
	c.fun_params(node.params)
	c.stmts(node.stmts)
	c.close_scope()

	if node.return_type != ast.VOID_TYPE and not has_toplevel_return(node.stmts) and not c.returns {
		c.error('missing return statement', node.pos)
	}

	c.cur_fun = ast.FunDecl{
		return_type = ast.VOID_TYPE
	}
}

fun (c Checker) fun_params(params []ast.Param){
	for p in params {
		if c.scope.is_known(p.name) {
			c.error('cannot shadow import "${p.name}"', p.pos)
			continue
		}

		sym := c.table.get_sym(p.typ)
		if sym.kind == .fun_ {
			c.scope.register(p.name, ast.ScopeObject{
				typ = p.typ
				kind = .function
			})
		} else {
			c.scope.register(p.name, ast.ScopeObject{
				typ = p.typ
				is_mut = p.is_mut
				kind = .variable
			})
		}
	}
}

fun (mut c Checker) check_main_fun(stmts []ast.Stmt) {
	for stmt in stmts {
		if stmt is ast.FunDecl and stmt.name == 'main' {
			c.has_main_fun = true
		}
	}
}

fun (mut c Checker) call_expr(node ast.CallExpr) ast.Type {
	if node.is_method{
		return c.method_call(node)
	}

	return c.fun_call(node)
}

fun (mut c Checker) fun_call(mut node ast.CallExpr) ast.Type {
	mut found := c.table.fun_decls.contains(node.name)
	if not found and not node.name.contains('.') and node.pkg != 'builtin' {
		full_name := node.pkg + '.' + node.name
		if c.table.fun_decls.contains(full_name) {
			node.name = full_name
			found = true
		}
	}
	if not found {
		obj := c.scope.get(node.name)
		if obj.kind == .function {
			found = true
		}
	}
	if not found {
		c.error('unknown function ${node.name}', node.pos)
		return ast.PLACEHOLDER_TYPE
	}

	mut def := c.table.fun_decls[node.name]
	if not def.is_pub and def.pkg != c.pkg {
		c.error('function ${def.name} is private', node.pos)
	}
	node.return_type = def.return_type

	c.check_fun_attrs_on_call(node, def)

	// Check argument count
	if node.args.length != def.params.length {
		c.error('expected ${def.params.length} arguments but got ${node.args.length}', node.pos)
		return node.return_type
	}

	// Handle special builtin functions
	if node.name == 'println' or node.name == 'eprintln' {
		node.args[0].typ = c.expr(node.args[0].expr)
		return ast.VOID_TYPE
	}


	// Check argument types
	c.call_args(def, mut node)

	if node.concrete_types.length > 0 {
		def.concrete_types.push(node.concrete_types)

		ret_sym := c.table.get_sym(node.return_type)
		if ret_sym.kind == .generic {
			node.return_type = node.concrete_types[def.generic_names.index(ret_sym.name)]
		}
	}

	return node.return_type
}

fun (mut c Checker) method_call(mut node ast.CallExpr) ast.Type {
	left_expr_type := c.expr(node.left)

	if left_expr_type == ast.PLACEHOLDER_TYPE {
		// Another error was already raised
		return ast.PLACEHOLDER_TYPE
	}

	left_sym := c.table.get_sym(left_expr_type)
	final_sym := c.table.get_final_sym(left_expr_type)
	mut def := c.table.get_method(left_sym, node.name)
	if def.name.length == 0 {
		// Autogenerated str method
		if node.name == 'str' {
			if node.args.length > 0 {
				c.error('expected 0 arguments but got ${node.args.length}', node.pos)
				return ast.STRING_TYPE
			}

			c.table.needed_str_funs.push(left_expr_type)
			node.return_type = ast.STRING_TYPE
			node.left_type = left_expr_type
			return node.return_type
		}

		c.error('method ${node.name} not found on type ${left_sym.name}', node.pos)
		return ast.PLACEHOLDER_TYPE
	}
	if not def.is_pub and left_sym.pkg != c.pkg {
		c.error('method ${def.name} is private', node.pos)
	}

	node.lang = def.lang
	node.return_type = def.return_type

	// Check if the receiver is and should be mutable
	if def.params[0].is_mut {
		if node.left is ast.Ident and not (node.left as ast.Ident).is_mut {
			c.error('method requires an mutable receiver', node.pos)
			return node.return_type
		}
	}

	// Set the receiver to be a pointer if the method expects one
	if left_expr_type.get_nr_amp() < def.params[0].typ.get_nr_amp() {
		node.left = ast.PrefixExpr{
			op = .amp
			right = node.left
		}
	}

	// The following is required for some builtin array and map methods
	node.left_type = def.params[0].typ
	if final_sym.kind == .array and ['push', 'push_many_with_len', 'push_many'].contains(node.name) {
		node.left_type = left_expr_type
	}

	c.check_fun_attrs_on_call(node, def)

	// Check argument count
	if node.args.length + 1 != def.params.length {
		c.error('expected ${def.params.length - 1} arguments but got ${node.args.length}', node.pos)
		return node.return_type
	}

	// Array methods with one argument of `any` type, expecting the element
	if final_sym.kind == .array and ['push', 'push_many_with_len', 'contains'].contains(node.name) {
		mut arg := node.args[0]
		info := final_sym.info as ast.ArrayInfo
		c.expected_type = info.elem_type
		arg.typ = c.expr(arg.expr)
		if not c.check_types(arg.typ, info.elem_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(info.elem_type)} in argument 1', node.pos)
		}
		return node.return_type
	}
	// Array methods with one argument of `array` type, expecting the specific array type
	if final_sym.kind == .array and ['concat', 'push_many'].contains(node.name) {
		mut arg := node.args[0]
		c.expected_type = left_expr_type
		arg.typ = c.expr(arg.expr)
		if not c.check_types(arg.typ, left_expr_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(left_expr_type)} in argument 1', node.pos)
		}
		return node.return_type
	}

	// Check argument types
	c.call_args(def, mut node)

	// Array methods with return type `array`
	if left_sym.kind == .array and ['filter', 'reverse', 'slice', 'copy', 'from_js_arr'].contains(node.name) {
		return left_expr_type
	}

	if node.concrete_types.length > 0 {
		def.concrete_types.push(node.concrete_types)

		ret_sym := c.table.get_sym(node.return_type)
		if ret_sym.kind == .generic {
			node.return_type = node.concrete_types[def.generic_names.index(ret_sym.name)]
		}
	}

	return node.return_type
}

fun (mut c Checker) call_args(def ast.FunDecl, mut node ast.CallExpr) {
	should_resolve_generics := def.generic_names.length != node.concrete_types.length
	mut save_as_concrete := false

	mut poffset := 0
	if node.is_method {
		poffset = 1
	}

	for i, mut arg in node.args {
		mut param_type := def.params[i + poffset].typ
		psym := c.table.get_sym(param_type)

		if should_resolve_generics and psym.kind == .generic {
			gi := def.generic_names.index(psym.name)
			if gi < node.concrete_types.length {
				param_type = node.concrete_types[gi]
			} else {
				save_as_concrete = true
			}
		}

		c.expected_type = param_type
		arg.typ = c.expr(arg.expr)
		if arg.typ == ast.VOID_TYPE and not (arg.expr is ast.CallExpr) {
			// Another error was already raised
			continue
		}

		if save_as_concrete {
			node.concrete_types.push(arg.typ)
			save_as_concrete = false
		}

		if not c.check_types(arg.typ, param_type) {
			c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
		}
	}
}

fun has_toplevel_return(stmts []ast.Stmt) bool {
	for stmt in stmts {
		if stmt is ast.ReturnStmt {
			return true
		}
		if stmt is ast.ExprStmt {
			if stmt.expr is ast.CallExpr {
				expr := stmt.expr as ast.CallExpr
				if not expr.is_method and ['panic', 'exit'].contains(expr.name) {
					return true
				}
			}
		}
	}
	return false
}
