// SPDX-FileCopyrightText: 2024-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package checker

import bait.ast
import bait.errors
import bait.token

struct FunRedefinition {
	path string
	pos token.Pos
	name string
	signature string
}

fun (mut c Checker) check_fun_redefinitions(files []ast.File) {
	if c.redefined_funs.length == 0 {
		return
	}

	// Note: It is assumed that there are at most a few redefined functions.
	// Thus the performance impact of looping over all files and root stmts is ok.
	for name in c.redefined_funs {
		// Collect information about redefinitions
		mut redefinitions := []FunRedefinition
		for file in files {
			for stmt in file.stmts {
				if stmt is ast.FunDecl and stmt.name == name {
					redefinitions.push(FunRedefinition{
						path = file.path
						pos = stmt.pos
						name = name
						signature = c.fun_signature(stmt)
					})
				}
			}
		}

		// Raise the error and show where redefinitions happened
		errors.generic_error('redfinition of function "${name}"')
		for redef in redefinitions {
			errors.info('conflict', redef.path, redef.pos, redef.signature)
		}
	}
}

fun (c Checker) fun_signature(node ast.FunDecl) string {
	mut sig := 'fun ${node.name}('
	for i, p in node.params {
		type_name := c.table.get_sym(p.typ).name
		sig += '${p.name} ${type_name}'
		if i < node.params.length - 1 {
			sig += ', '
		}
	}
	sig += ')'
	return sig
}
