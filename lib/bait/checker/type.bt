// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package checker

import bait.ast
import bait.token

fun (c Checker) check_types(got ast.Type, expected ast.Type) bool {
	if got == expected {
		return true
	}

	if got.idx() == expected.idx() {
		return true
	}

	// TODO remove any type
	if got == ast.ANY_TYPE or expected == ast.ANY_TYPE {
		return true
	}
	got_sym := c.table.get_sym(got)
	exp_sym := c.table.get_sym(expected)
	if exp_sym.kind == .array and got_sym.kind == .array {
		if exp_sym.name == 'array' or got_sym.name == 'array' {
			return true
		}
		// TODO remove any type
		got_info := got_sym.info as ast.ArrayInfo
		if got_info.elem_type == ast.ANY_TYPE {
			return true
		}
		exp_info := exp_sym.info as ast.ArrayInfo
		if exp_info.elem_type == ast.ANY_TYPE {
			return true
		}
	}
	if exp_sym.kind == .sum_type {
		info := exp_sym.info as ast.SumTypeInfo
		return info.variants.contains(got)
	}
	if got_sym.kind == .fun_ and exp_sym.kind == .fun_ {
		got_info := got_sym.info as ast.FunInfo
		exp_info := exp_sym.info as ast.FunInfo
		if got_info.param_types.length != exp_info.param_types.length {
			return false
		}
		for i := 0; i < got_info.param_types.length; i += 1 {
			if not c.check_types(got_info.param_types[i], exp_info.param_types[i]) {
				return false
			}
		}
		return c.check_types(got_info.return_type, exp_info.return_type)
	}
	return false
}

fun (c Checker) does_type_exist(sym ast.TypeSymbol, pos token.Pos) bool {
	if sym.kind == .placeholder {
		c.error('unknown type ${sym.name}', pos)
		return false
	}

	if sym.kind == .other or sym.kind == .string {
		return true
	}

	if sym.is_pub or sym.pkg == c.pkg {
		return true
	}

	if sym.kind == .array {
		info := sym.info as ast.ArrayInfo
		elem_sym := c.table.get_sym(info.elem_type)
		return c.does_type_exist(elem_sym, pos)
	}

	if sym.kind == .map {
		info := sym.info as ast.MapInfo
		key_sym := c.table.get_sym(info.key_type)
		val_sym := c.table.get_sym(info.val_type)
		return c.does_type_exist(key_sym, pos) and c.does_type_exist(val_sym, pos)
	}

	if sym.kind == .alias_type {
		parent_sym := c.table.get_sym(sym.parent)
		return c.does_type_exist(parent_sym, pos)
	}

	if sym.kind == .sum_type {
		info := sym.info as ast.SumTypeInfo
		for variant in info.variants {
			var_sym := c.table.get_sym(variant)
			if not c.does_type_exist(var_sym, pos) {
				return false
			}
		}
		return true
	}

	c.error('type ${sym.name} is private', pos)
	return false
}
