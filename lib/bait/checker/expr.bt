// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package checker

import bait.ast
import bait.errors
import bait.token

fun (c Checker) expr(expr ast.Expr) ast.Type {
	if expr is ast.AnonFun {
		return c.anon_fun(expr)
	} else if expr is ast.ArrayInit {
		return c.array_init(expr)
	} else if expr is ast.AsCast {
		return c.as_cast(expr)
	} else if expr is ast.BoolLiteral {
		return ast.BOOL_TYPE
	} else if expr is ast.CallExpr {
		return c.call_expr(expr)
	} else if expr is ast.CharLiteral {
		return ast.U8_TYPE
	} else if expr is ast.CompTimeVar {
		return c.comp_time_var(expr)
	} else if expr is ast.EnumVal {
		return c.enum_val(expr)
	} else if expr is ast.Ident {
		return c.ident(expr)
	} else if expr is ast.IfExpr {
		return c.if_expr(expr)
	} else if expr is ast.IndexExpr {
		return c.index_expr(expr)
	} else if expr is ast.InfixExpr {
		return c.infix_expr(expr)
	} else if expr is ast.IntegerLiteral {
		return ast.I32_TYPE
	} else if expr is ast.MapInit {
		return c.map_init(expr)
	} else if expr is ast.MatchExpr {
		return c.match_expr(expr)
	} else if expr is ast.ParExpr {
		return c.par_expr(expr)
	} else if expr is ast.PrefixExpr {
		return c.prefix_expr(expr)
	} else if expr is ast.SelectorExpr {
		return c.selector_expr(expr)
	} else if expr is ast.StringLiteral {
		return c.string_literal(expr)
	} else if expr is ast.StringInterLiteral {
		return c.string_inter_literal(expr)
	} else if expr is ast.StructInit {
		return c.struct_init(expr)
	} else if expr is ast.TypeOf {
		return c.type_of(expr)
	} else {
		c.error('unexpected expr: ${expr}', expr.pos)
	}
}

fun (c Checker) anon_fun(node ast.AnonFun) ast.Type {
	root_fun_decl := c.cur_fun
	c.cur_fun = node.decl
	c.open_scope()
	c.fun_params(node.decl.params)
	c.stmts(node.decl.stmts)
	c.close_scope()
	c.cur_fun = root_fun_decl
	return node.typ
}

fun (c Checker) array_init(node ast.ArrayInit) ast.Type {
	if node.exprs.length > 0 {
		for i, e in node.exprs {
			typ := c.expr(e)
			if i == 0 {
				node.elem_type = typ
				c.expected_type = typ
			}
		}
		node.typ = c.table.find_or_register_array(node.elem_type)
	}
	return node.typ
}

fun (c Checker) as_cast(node ast.AsCast) ast.Type {
	expr_type := c.expr(node.expr)
	node.expr_type = expr_type
	expr_sym := c.table.get_sym(expr_type)

	// Check the target exists
	target_sym := c.table.get_sym(node.target)
	if target_sym.kind == .placeholder {
		c.error('unknown type ${target_sym.name}', node.pos)
		return expr_type
	}

	// TODO check cast is possible (e.g. prevent string to i32, ...)

	// Smartcast sumtypes
	// TODO check if expr is part of target
	if expr_sym.kind == .sum_type and node.expr is ast.Ident {
		expr := node.expr as ast.Ident
		c.scope.update_type(expr.name, node.target)
	}

	return node.target
}

fun (c Checker) call_expr(node ast.CallExpr) ast.Type {
	if node.is_method{
		return c.method_call(node)
	}
	return c.fun_call(node)
}

fun (c Checker) fun_call(node ast.CallExpr) ast.Type {
	mut found := c.table.fun_decls.contains(node.name)
	if not found and not node.name.contains('.') and node.pkg != 'builtin' {
		full_name := node.pkg + '.' + node.name
		if c.table.fun_decls.contains(full_name) {
			node.name = full_name
			found = true
		}
	}
	if not found {
		obj := c.scope.get(node.name)
		if obj.kind == .function {
			found = true
		}
	}
	if found {
		def := c.table.fun_decls[node.name]
		if not def.is_pub and node.pkg != c.pkg {
			c.error('function ${def.name} is private', node.pos)
		}
		if node.args.length == def.params.length {
			if node.name == 'println' {
				// TODO check arg can be printed
				for arg in node.args {
					arg.typ = c.expr(arg.expr)
				}
				return ast.VOID_TYPE
			}
			for i, arg in node.args {
				param_type := def.params[i].typ
				c.expected_type = param_type
				arg.typ = c.expr(arg.expr)
				if not c.check_types(arg.typ, param_type) {
					c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
				}
			}
		} else {
			c.error('expected ${def.params.length} arguments but got ${node.args.length}', node.pos)
		}
		node.return_type = def.return_type
		c.check_attributes_on_call(node, def)
	} else {
		c.error('unknown function ${node.name}', node.pos)
	}
	return node.return_type
}

fun (c Checker) method_call(node ast.CallExpr) ast.Type {
	left_expr_type := c.expr(node.left)
	left_sym := c.table.get_sym(left_expr_type)
	def := c.table.get_method(left_sym, node.name)
	if def.name.length == 0 {
		c.error('method ${node.name} not found on type ${left_sym.name}', node.pos)
		return ast.VOID_TYPE
	}
	if not def.is_pub and left_sym.pkg != c.pkg {
		c.error('method ${def.name} is private', node.pos)
	}
	if node.args.length + 1 == def.params.length {
		for i, arg in node.args {
			param_type := def.params[i + 1].typ
			c.expected_type = param_type
			arg.typ = c.expr(arg.expr)
			if not c.check_types(arg.typ, param_type) {
				c.error('type ${c.table.type_name(arg.typ)} not matches ${c.table.type_name(param_type)} in argument ${i + 1}', node.pos)
			}
		}
	} else {
		c.error('expected ${def.params.length - 1} arguments but got ${node.args.length}', node.pos)
	}
	node.left_type = def.params[0].typ
	node.return_type = def.return_type
	c.check_attributes_on_call(node, def)
	return node.return_type
}

fun (c Checker) check_attributes_on_call(call ast.CallExpr, def ast.FunDecl) {
	mut is_deprecated := false
	mut depr_attr := ast.Attribute{}
	mut depr_date_attr := ast.Attribute{}

	for attr in def.attrs {
		if attr.name == 'deprecated_after' {
			depr_date_attr = attr
			is_deprecated = true
		}
		if attr.name == 'deprecated' {
			depr_attr = attr
			is_deprecated = true
		}
	}

	if is_deprecated {
		mut depr_message := 'function "${call.name}" '
		if depr_date_attr.name.length > 0 {
			depr_message += 'will be deprecated after ${depr_date_attr.value}'
		} else {
			depr_message += 'is deprecated'
		}
		if depr_attr.value.length > 0 {
			depr_message += '; ${depr_attr.value}'
		}
		errors.notice('note', c.path, call.pos, depr_message)
		// TODO check deprecation date and warn if passed
	}
}

const SUPPORTED_COMPTIME_VARS := [
	'PKG',
	'FILE',
	'ABS_FILE',
	'LINE',
	'FILE_LINE',
	'FUN',
	'BAITEXE',
	'BAITDIR',
	'BAITHASH',
]

fun (c Checker) comp_time_var(node ast.CompTimeVar) ast.Type {
	if not SUPPORTED_COMPTIME_VARS.contains(node.name) {
		c.error('unsupported comptime var "${node.name}"', node.pos)
	}
	return ast.STRING_TYPE
}

fun (c Checker) enum_val(node ast.EnumVal) ast.Type {
	if node.name.length == 0 {
		node.typ = c.expected_type
	} else {
		node.typ = c.table.get_idx(node.name)
	}
	sym := c.table.get_sym(node.typ)
	if sym.kind == .placeholder {
		c.error('undefined enum ${node.name}', node.pos)
		return ast.VOID_TYPE
	}
	if sym.kind != .enum_ {
		c.error('expected type is not an enum, got ${sym.name}', node.pos)
		return ast.VOID_TYPE
	}
	if not sym.is_pub and sym.name.contains('.') and sym.pkg != c.pkg {
		c.error('enum ${sym.name} is private', node.pos)
		return ast.VOID_TYPE
	}
	info := sym.info as ast.EnumInfo
	if not info.vals.contains(node.val) {
		c.error('enum ${sym.name} has no value ${node.val}', node.pos)
		return ast.VOID_TYPE
	}
	node.name = sym.name
	return node.typ
}

fun (c Checker) ident(node ast.Ident) ast.Type {
	mut obj := c.scope.get(node.name)
	if obj.typ != ast.PLACEHOLDER_TYPE {
		return obj.typ
	}
	if not node.name.contains('.') and node.pkg != 'builtin' and node.pkg != 'main' {
		node.name = node.pkg + '.' + node.name
	}
	obj = c.table.global_scope.get(node.name)
	if obj.typ == ast.PLACEHOLDER_TYPE {
		c.error('undefined variable ${node.name}', node.pos)
	}
	// unresolved constant
	if obj.typ == ast.VOID_TYPE {
		obj.typ = c.expr(obj.expr)
	}
	if obj.kind == .constant and not obj.is_pub and node.pkg != c.pkg {
		c.error('const ${node.name} is private', node.pos)
	}
	return obj.typ
}

fun (c Checker) if_expr(node ast.IfExpr) ast.Type {
	for i, b in node.branches {
		if not node.has_else or i < node.branches.length - 1 {
			c.expr(b.cond)
		}
		c.open_scope()
		c.stmts(b.stmts)
		c.close_scope()
	}
	// TODO make an actual expression
	return ast.VOID_TYPE
}

fun (c Checker) index_expr(node ast.IndexExpr) ast.Type {
	node.left_type = c.expr(node.left)
	c.expr(node.index)
	sym := c.table.get_sym(node.left_type)
	if sym.kind == .array {
		info := sym.info as ast.ArrayInfo
		return info.elem_type
	}
	if sym.kind == .map {
		info := sym.info as ast.MapInfo
		return info.val_type
	}
	if sym.kind == .string {
		if c.is_lhs_assign{
			c.error('cannot assign to string index', node.pos)
			return ast.VOID_TYPE
		}
		return ast.U8_TYPE
	}
	return node.left_type
}

fun (c Checker) map_init(node ast.MapInit) ast.Type {
	if node.keys.length > 0 {
		for i, key in node.keys {
			key_type := c.expr(key)
			val_type := c.expr(node.vals[i])
			if i == 0 {
				node.key_type = key_type
				node.val_type = val_type
			}
		}
		node.typ = c.table.find_or_register_map(node.key_type, node.val_type)
	} else {
		sym := c.table.get_sym(node.typ)
		info := sym.info as ast.MapInfo
		node.key_type = info.key_type
		node.val_type = info.val_type
	}
	return node.typ
}

fun (c Checker) match_expr(node ast.MatchExpr) ast.Type {
	node.cond_type = c.expr(node.cond)
	if node.branches.length == 0 {
		c.error('match expression must have at least one branch', node.pos)
		return ast.VOID_TYPE
	}
	sym := c.table.get_sym(node.cond_type)
	node.is_sumtype = sym.kind == .sum_type
	for branch in node.branches {
		c.open_scope()
		for e in branch.exprs {
			if node.is_sumtype {
				expr := e as ast.Ident
				variant := c.table.get_idx(expr.name)
				info := sym.info as ast.SumTypeInfo
				if not info.variants.contains(variant) {
					c.error('sum type ${sym.name} has no variant ${expr.name}', expr.pos)
					continue
				}
				cond := node.cond as ast.Ident
				c.scope.update_type(cond.name, variant)
			} else {
				c.expected_type = node.cond_type
				expr_type := c.expr(e)
				if not c.check_types(expr_type, node.cond_type) {
					expr := e as ast.EmptyExpr
					c.error('cannot match ${c.table.type_name(expr_type)} to ${sym.name}', expr.pos)
				}
				branch.expr_types.push(expr_type)
			}
		}
		c.stmts(branch.stmts)
		c.close_scope()
	}
	// TODO make an actual expression
	return ast.VOID_TYPE
}

fun (c Checker) par_expr(node ast.ParExpr) ast.Type {
	return c.expr(node.expr)
}

fun (c Checker) prefix_expr(node ast.PrefixExpr) ast.Type {
	typ := c.expr(node.right)
	return typ
}

fun (c Checker) selector_expr(node ast.SelectorExpr) ast.Type {
	if node.expr is ast.IndexExpr {
		expr := node.expr as ast.IndexExpr
		expr.is_selector = true
	}
	typ := c.expr(node.expr)
	sym := c.table.get_sym(typ)
	if [ast.TypeKind.struct_, .array, .string, .map].contains(sym.kind) {
		field := sym.find_field(node.field_name, c.table)
		if field.name.length == 0 {
			c.error('${sym.name} has no field ${node.field_name}', node.pos)
			return ast.VOID_TYPE
		}
		return field.typ
	}
	if sym.kind == .sum_type {
		// TODO check if field is present on all variants (with same type)
		c.error('cast to the variant before accessing field of sumtype ${sym.name}', node.pos)
		return ast.VOID_TYPE
	}
	// TODO other variants of selector expr
	return ast.ANY_TYPE
}

fun (c Checker) string_literal(node ast.StringLiteral) ast.Type {
	if node.lang != .bait {
		if not c.is_js_file {
			c.warn('JS code can only be used in .js.bt files', node.pos)
		}
		return ast.VOID_TYPE
	}
	return ast.STRING_TYPE
}

fun (c Checker) string_inter_literal(node ast.StringInterLiteral) ast.Type {
	for e in node.exprs {
		typ := c.expr(e)
		node.expr_types.push(typ)
	}
	return ast.STRING_TYPE
}

fun (c Checker) struct_init(node ast.StructInit) ast.Type {
	sym := c.table.get_sym(node.typ)
	if sym.kind == .placeholder {
		c.error('undefined struct ${node.name}', node.pos)
		return ast.VOID_TYPE
	}
	if not sym.is_pub and sym.name.contains('.') and sym.pkg != c.pkg {
		c.error('struct ${sym.name} is private', node.pos)
		return ast.VOID_TYPE
	}
	node.name = sym.name
	for field in node.fields {
		def := sym.find_field(field.name, c.table)
		if def.name.length == 0 {
			c.error('struct ${sym.name} has no field ${field.name}', node.pos)
		}
		c.expected_type = def.typ
		expr_type := c.expr(field.expr)
		if not c.check_types(expr_type, def.typ) {
			c.error('cannot assign to field ${field.name}: expected ${c.table.type_name(def.typ)}, got ${c.table.type_name(expr_type)} ', node.pos)
		}
	}
	return node.typ
}

fun (c Checker) type_of(node ast.TypeOf) ast.Type {
	typ := c.expr(node.expr)
	node.typ = typ
	return ast.STRING_TYPE
}
