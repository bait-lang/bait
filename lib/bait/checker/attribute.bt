// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package checker

import bait.ast
import bait.errors

enum AttrValue {
	none
	optional
	required
}

fun build_known_attrs() map[string]AttrValue {
	mut attrs := map[string]AttrValue
	attrs['deprecated'] = .optional
	attrs['deprecated_after'] = .required
	attrs['overload'] = .required
	return attrs
}

const KNOWN_ATTRS := build_known_attrs()

fun (c Checker) check_attributes(node ast.FunDecl){
	for attr in node.attrs {
		// Check attribute is implemented
		if not KNOWN_ATTRS.contains(attr.name) {
			c.warn('unknown attribute "${attr.name}"', attr.pos)
			continue
		}

		// Check value requirements are met
		val_req := KNOWN_ATTRS[attr.name]
		if val_req == .none and attr.value.length > 0 {
			c.error('attribute "${attr.name}" does not take a value', attr.pos)
			continue
		}
		if val_req == .required and attr.value.length == 0 {
			c.error('attribute "${attr.name}" requires a value', attr.pos)
			continue
		}

		if attr.name == 'overload' {
			c.attr_overload(node, attr)
		}
	}
}

fun (c Checker) attr_overload(node ast.FunDecl, attr ast.Attribute) {
	if not node.is_method {
		c.warn('operator overloading can only be used on methods', attr.pos)
		return
	}

	// Check the operator can be overloaded
	if ['!=', '>', '<=', '>='].contains(attr.value) {
		c.error('cannot overload "!=", ">", "<=" and ">=" as they are generated from "==" and "<"', attr.pos)
		return
	}
	if not ['+', '-', '*', '/', '%', '==', '<'].contains(attr.value) {
		c.error('cannot overload "${attr.value}"', attr.pos)
		return
	}

	// Check for duplicate overload
	rec_sym := c.table.get_sym(node.params[0].typ)
	if rec_sym.overloads.contains(attr.value) {
		// TODO print positions of all overloads
		c.error('"${attr.value}" was overloaded twice for type "${rec_sym.name}"', attr.pos)
		return
	}

	// Register overload method
	rec_sym.overloads[attr.value] = node
}
