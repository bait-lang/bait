// SPDX-FileCopyrightText: 2024-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MIT
package transformer

import bait.ast

pub struct Transformer {
}

pub fun (t Transformer) transform_files(files []&ast.File) {
	for mut file in files {
		t.stmts(mut file.stmts)
	}
}

pub fun (t Transformer) stmts(mut stmts []ast.Stmt) {
	// TODO js: fix for mut stmt in stmts {
	for i := 0; i < stmts.length; i += 1 {
		stmts[i] = t.stmt(mut stmts[i])
	}
}

fun (t Transformer) stmt(mut stmt ast.Stmt) ast.Stmt {
	match stmt {
		ast.AssertStmt {}
		ast.AssignStmt {}
		ast.ConstDecl {}
		ast.ExprStmt {}
		ast.EnumDecl {}
		ast.ForLoop {}
		ast.ForClassicLoop {}
		ast.ForInLoop {}
		ast.FunDecl {}
		ast.StaticDecl {}
		ast.IfMatch {}
		ast.InterfaceDecl {}
		ast.LoopControlStmt {}
		ast.ReturnStmt {}
		ast.StructDecl {}
		ast.TypeDecl {}
		ast.Void {}
		ast.InvalidStmt {}
	}
	return stmt
}

fun (t Transformer) expr(mut expr ast.Expr) ast.Expr {
	match expr {
		ast.AnonFun {}
		ast.ArrayInit {}
		ast.AsCast {}
		ast.BoolLiteral {}
		ast.CallExpr {}
		ast.CharLiteral {}
		ast.ComptimeVar {}
		ast.EnumVal {}
		ast.FloatLiteral {}
		ast.HashExpr {}
		ast.Ident {}
		ast.IfMatch {}
		ast.IndexExpr {}
		ast.InfixExpr {}
		ast.IntegerLiteral {}
		ast.MapInit {}
		ast.ParExpr {}
		ast.PrefixExpr {}
		ast.SelectorExpr {}
		ast.StringLiteral {}
		ast.StringInterLiteral {}
		ast.StructInit {}
		ast.TypeOf {}
		ast.Void {}
		ast.InvalidExpr {}
	}
	return expr
}
