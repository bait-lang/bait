// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (mut p Parser) toplevel_stmt() ast.Stmt {
	match p.tok.kind {
		.key_pub{
			return p.pub_stmt()
		}
		.hash {
			return p.expr_stmt()
		}
		.key_const{
			return p.const_decl()
		}
		.key_enum{
			return p.enum_decl()
		}
		.key_fun{
			return p.fun_decl()
		}
		.key_global{
			return p.global_decl()
		}
		.key_interface{
			return p.interface_decl()
		}
		.key_struct{
			return p.struct_decl()
		}
		.key_type{
			return p.type_decl()
		}
		else{
			if p.pkg_name == 'main' {
				return p.script_mode_main()
			}
			p.error('bad toplevel token: kind = ${p.tok.kind}, val = ${p.tok.val}')
		}
	}
}

fun (mut p Parser) pub_stmt() ast.Stmt {
	match p.next_tok.kind {
		.key_const{
			return p.const_decl()
		}
		.key_enum{
			return p.enum_decl()
		}
		.key_fun{
			return p.fun_decl()
		}
		.key_interface{
			return p.interface_decl()
		}
		.key_struct{
			return p.struct_decl()
		}
		else{
			p.error('cannot use pub keyword before ${p.next_tok.kind}')
		}
	}
}

fun (mut p Parser) script_mode_main() ast.FunDecl {
	if not p.pref.is_script {
		p.warn('declare the main function or use the --script option')
	}
	mut stmts := []ast.Stmt
	for not p.should_abort and p.tok.kind != .eof {
		stmts.push(p.stmt())
	}
	mut node := ast.FunDecl{
		name = 'main'
	}
	p.table.fun_decls['main'] = node
	node.stmts = stmts
	return node
}

fun (mut p Parser) stmt() ast.Stmt {
	match p.tok.kind {
		.name {
			return p.stmt_with_name()
		}
		.key_assert {
			return p.assert_stmt()
		}
		.key_mut {
			return p.assign_stmt()
		}
		.key_break, .key_continue {
			return p.loop_control_stmt()
		}
		.key_for {
			return p.for_loop('')
		}
		.key_return {
			return p.return_stmt()
		}
		else{
			return p.expr_stmt()
		}
	}
}

fun (mut p Parser) stmt_with_name()ast.Stmt{
	if p.next_tok.kind == .colon {
		label := p.tok.val
		p.next()
		p.next()
		return p.for_loop(label)
	}

	left := p.expr(0)
	if p.tok.kind.is_assign() {
		return p.partial_assign_stmt(left)
	}
	return ast.ExprStmt{expr = left}
}

fun (mut p Parser) assert_stmt() ast.AssertStmt{
	p.next()
	pos := p.tok.pos
	expr := p.expr(0)
	return ast.AssertStmt{
		expr = expr
		pos = pos
	}
}

fun (mut p Parser) assign_stmt() ast.AssignStmt {
	pos := p.tok.pos
	left := p.expr(0)
	return p.partial_assign_stmt(left)
}

fun (mut p Parser) partial_assign_stmt(left ast.Expr) ast.AssignStmt {
	pos := p.tok.pos
	op := p.tok.kind
	p.next()
	right := p.expr(0)
	return ast.AssignStmt{
		op = op
		left = left
		right = right
		pos = pos
	}
}

fun (mut p Parser) const_decl()ast.ConstDecl{
	pos := p.tok.pos
	is_pub := p.check_pub()
	p.next()

	lang := p.parse_lang()
	mut name := ''

	// foreign package
	if lang == .js and p.next_tok.kind == .dot {
		name = 'JS__' + p.check_name() + '.'
		p.next()
	}

	// normal name and bait package
	name += p.check_name()
	if lang == .bait {
		name = p.prepend_pkg(name)
	}

	p.check(.decl_assign)
	mut expr := ast.EmptyExpr{} as ast.Expr
	mut typ := ast.PLACEHOLDER_TYPE
	if lang == .bait {
		expr = p.expr(0)
		typ = p.infer_expr_type(expr)
	} else {
		typ = p.parse_type()
	}

	p.table.global_scope.register(name, ast.ScopeObject{
		typ = typ
		kind = .constant
		is_pub = is_pub
		pkg = p.pkg_name
		expr = expr
	})

	return ast.ConstDecl{
		name = name
		expr = expr
		typ = typ
		pos = pos
		lang = lang
	}
}

fun (mut p Parser) loop_control_stmt()ast.LoopControlStmt{
	pos := p.tok.pos
	kind := p.tok.kind
	p.next()

	mut label := ''
	if p.tok.kind == .name and p.tok.pos.line == p.prev_tok.pos.line {
		label = p.check_name()
	}

	return ast.LoopControlStmt{
		kind = kind
		label = label
		pos = pos
	}
}

fun (mut p Parser) expr_stmt()ast.ExprStmt{
	expr := p.expr(0)
	return ast.ExprStmt{
		expr = expr
	}
}

fun (mut p Parser) enum_decl()ast.EnumDecl{
	pos := p.tok.pos
	is_pub := p.check_pub()
	p.next()
	name := p.prepend_pkg(p.check_name())
	p.check(.lcur)
	mut variants := []string
	mut fields := []ast.EnumField
	for p.tok.kind != .rcur {
		fpos := p.tok.pos
		fname := p.check_name()
		mut expr := ast.EmptyExpr{} as ast.Expr
		if p.tok.kind == .decl_assign {
			p.next()
			expr = p.expr(0)
		}
		variants.push(fname)
		fields.push(ast.EnumField{
			name = fname
			expr = expr
			pos = fpos
		})
	}
	p.check(.rcur)
	p.table.register_sym(ast.TypeSymbol{
		name = name
		is_pub = is_pub
		pkg = p.pkg_name
		kind = .enum_
		info = ast.EnumInfo{
			vals = variants
		}
	})
	return ast.EnumDecl{
		name = name
		fields = fields
		pos = pos
	}
}

fun (mut p Parser) global_decl()ast.GlobalDecl{
	pos := p.tok.pos
	p.check(.key_global)
	name := p.prepend_pkg(p.check_name())
	p.check(.decl_assign)
	expr := p.expr(0)
	typ := p.infer_expr_type(expr)
	p.table.global_scope.register(name, ast.ScopeObject{
		typ = typ
		kind = .global_
	})
	return ast.GlobalDecl{
		name = name
		expr = expr
		pos = pos
	}
}

fun (mut p Parser) interface_decl()ast.InterfaceDecl{
	pos := p.tok.pos
	is_pub := p.check_pub()
	p.check(.key_interface)
	lang := p.parse_lang()
	name := lang.prepend_to(p.check_name())

	// TODO investigate why registration of the sym after loop with methods as struct field does not work
	mut tsym := ast.TypeSymbol{
		kind = .interface_
		name = name
		is_pub = is_pub
		pkg = p.pkg_name
	}
	typ := p.table.register_sym(tsym)

	mut methods := []ast.FunDecl
	mut fields := []ast.StructField
	p.check(.lcur)
	for p.tok.kind != .rcur {
		fname := p.check_name()
		if p.tok.kind == .lpar {
			m := p.interface_method(fname, typ)
			methods.push(m)
			tsym.methods.push(m)
			continue
		}

		fields.push(ast.StructField{
			name = fname
			typ = p.parse_type()
		})
	}
	p.next()

	tsym.info = ast.StructInfo {
		fields = fields
	}

	return ast.InterfaceDecl{
		lang = lang
		name = name
		typ = typ
		methods = methods
		fields = fields
		pos = pos
	}
}

fun (mut p Parser) interface_method(name string, rec_type ast.Type) ast.FunDecl {
	p.check(.lpar)
	// The first param is a fictional receiver in this case
	mut params := [ast.Param{
		name = '_'
		typ = rec_type
	}]
	params = params.concat(p.fun_params())
	p.check(.rpar)
	mut return_type := ast.VOID_TYPE
	if p.tok.pos.line == p.prev_tok.pos.line {
		return_type = p.parse_type()
	}
	return ast.FunDecl{
		lang = .js
		name = name
		params = params
		return_type = return_type
		is_pub = true
		is_method = true
	}
}

fun (mut p Parser) return_stmt()ast.ReturnStmt{
	pos := p.tok.pos
	p.check(.key_return)
	mut expr := ast.EmptyExpr{} as ast.Expr
	if p.tok.pos.line == pos.line {
		expr = p.expr(0)
	}
	return ast.ReturnStmt{
		expr = expr
		pos = pos
	}
}

fun (mut p Parser) type_decl() ast.TypeDecl {
	pos := p.tok.pos
	is_pub := p.check_pub()
	p.next()
	name := p.prepend_pkg(p.check_name())
	p.check(.decl_assign)
	is_fun_type := p.tok.kind == .key_fun
	mut variants := []ast.Type
	variants.push(p.parse_type())

	// Function type
	if is_fun_type {
		sym := p.table.get_sym(variants[0])
		typ := p.table.register_sym(ast.TypeSymbol{
			kind = .fun_
			name = name
			is_pub = is_pub
			pkg = p.pkg_name
			info = sym.info
		})
		return ast.TypeDecl{
			name = name
			typ = typ
			pos = pos
		}
	}

	// Alias type
	if p.tok.kind != .pipe {
		typ := p.table.register_sym(ast.TypeSymbol{
			kind = .alias_type
			name = name
			parent = variants[0]
			is_pub = is_pub
			pkg = p.pkg_name
		})
		return ast.TypeDecl{
			name = name
			typ = typ
			pos = pos
		}
	}

	// Sum type
	for p.tok.kind == .pipe {
		p.next()
		variants.push(p.parse_type())
	}
	typ := p.table.register_sym(ast.TypeSymbol{
		kind = .sum_type
		name = name
		is_pub = is_pub
		pkg = p.pkg_name
		info = ast.SumTypeInfo{
			variants = variants
		}
	})
	return ast.TypeDecl{
		name = name
		typ = typ
		pos = pos
	}
}
