// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (p Parser) expr(precedence i32) ast.Expr {
	mut node := ast.EmptyExpr{} as ast.Expr
	match p.tok.kind {
		.hash {
			node = p.hash_expr()
		}
		.char {
			node = p.char_literal()
		}
		.dollar {
			node = p.comp_time_var()
		}
		.dot {
			node = p.enum_val(false)
		}
		.lbr {
			node = p.array_init()
		}
		.lpar {
			node = p.par_expr()
		}
		.name {
			node = p.name_expr()
		}
		.number {
			node = p.number_literal()
		}
		.string {
			node = p.string_literal()
		}
		.key_fun {
			node = p.anon_fun()
		}
		.key_false, .key_true {
			node = p.bool_literal()
		}
		.key_if {
			node = p.if_expr()
		}
		.key_match {
			node = p.match_expr()
		}
		.key_mut {
			node = p.ident()
		}
		.key_not, .minus {
			node = p.prefix_expr()
		}
		.key_typeof {
			node = p.typeof_expr()
		}
		else {
			mut msg := 'invalid expression: kind = ${p.tok.kind}'
			if p.tok.val.length > 0 {
				msg += ', val = ${p.tok.val}'
			}
			p.error(msg)
		}
	}
	return p.expr_with_left(node, precedence)
}

fun (p Parser) expr_with_left(left any, precedence i32) ast.Expr {
	for precedence < p.tok.precedence() as i32 {
		if p.tok.kind == .dot {
			left = p.dot_expr(left)
		} else if p.tok.kind == .lbr {
			left = p.index_expr(left)
		} else if p.tok.kind == .key_as {
			left = p.as_cast(left)
		} else if p.tok.kind.is_infix() {
			left = p.infix_expr(left)
		} else {
			return left
		}
	}
	return left
}

fun (p Parser) expr_list() []ast.Expr{
	mut exprs := []ast.Expr
	for true {
		exprs.push(p.expr(0))
		if p.tok.kind != .comma {
			break
		}
		p.check(.comma)
	}
	return exprs
}

fun (p Parser) anon_fun()ast.AnonFun{
	pos := p.tok.pos
	p.check(.key_fun)
	p.check(.lpar)
	params := p.fun_params()
	p.check(.rpar)
	mut return_type := ast.VOID_TYPE
	if p.tok.kind != .lcur {
		return_type = p.parse_type()
	}
	mut param_types := []ast.Type
	for param in params {
		param_types.push(param.typ)
	}
	typ := p.table.find_or_register_fun(param_types, return_type)
	stmts := p.parse_block()
	return ast.AnonFun{
		decl = ast.FunDecl{
			params = params
			return_type = return_type
			stmts = stmts
		}
		typ = typ
		pos = pos
	}
}

fun (p Parser) array_init()ast.ArrayInit{
	pos := p.tok.pos
	p.check(.lbr)

	// Type init, e.g. `[]i32`
	if p.tok.kind == .rbr {
		p.next()
		elem_type := p.parse_type()
		typ := p.table.find_or_register_array(elem_type)

		// Optional parameters, e.g. `[]i32{ length = 10 }`
		mut length_expr := ast.EmptyExpr{} as ast.Expr
		if p.tok.kind == .lcur {
			p.next()
			for p.tok.kind != .rcur {
				key := p.check_name()
				p.check(.assign)
				expr := p.expr(0)

				if key == 'length' {
					length_expr = expr
				} else {
					p.error('invalid array init field: ${key}')
				}
			}
			p.check(.rcur)
		}

		return ast.ArrayInit{
			typ = typ
			elem_type = elem_type
			length_expr = length_expr
			pos = pos
		}
	}

	// Expressions init, e.g. `[1, 2, 3]`
	mut exprs := []ast.Expr
	for p.tok.kind != .rbr {
		exprs.push(p.expr(0))
		if p.tok.kind == .comma {
			p.next()
		}
	}
	p.check(.rbr)
	return ast.ArrayInit{
		exprs = exprs
		pos = pos
	}
}

fun (p Parser) as_cast(left ast.Expr) ast.AsCast {
	pos := p.tok.pos
	p.check(.key_as)
	target := p.parse_type()
	return ast.AsCast{
		target = target
		expr = left
		pos = pos
	}
}

fun (p Parser) bool_literal()ast.BoolLiteral{
	pos := p.tok.pos
	val := p.tok.kind == .key_true
	p.next()
	return ast.BoolLiteral{
		val = val
		pos = pos
	}
}

fun (p Parser) char_literal()ast.CharLiteral{
	pos := p.tok.pos
	p.next()
	return ast.CharLiteral{
		val = p.prev_tok.val
		pos = pos
	}
}

fun (p Parser) comp_time_var() ast.CompTimeVar{
	pos := p.tok.pos
	p.next()
	name := p.check_name()
	return ast.CompTimeVar{
		name = name
		pos = pos
	}
}

fun (p Parser) dot_expr(left ast.Expr) ast.Expr {
	pos := p.tok.pos
	p.check(.dot)
	if p.next_tok.kind == .lpar {
		return p.method_call(left)
	}
	name := p.check_name()
	return ast.SelectorExpr{
		expr = left
		field_name = name
		pos = pos
	}
}

fun (p Parser) fun_call(lang ast.Language)ast.CallExpr{
	pos := p.tok.pos
	name := p.prepend_expr_pkg(p.check_name())
	p.check(.lpar)
	args := p.call_args()
	p.check(.rpar)
	return ast.CallExpr{
		name = name
		args = args
		pkg = p.pkg_name
		pos = pos
		lang = lang
	}
}

fun (p Parser) method_call(left ast.Expr) ast.CallExpr {
	pos := p.tok.pos
	name := p.check_name()
	p.check(.lpar)
	args := p.call_args()
	p.check(.rpar)
	return ast.CallExpr{
		is_method = true
		left = left
		name = name
		args = args
		pos = pos
	}
}

fun (p Parser) call_args() []ast.CallArg {
	mut args := []ast.CallArg
	for p.tok.kind != .rpar {
		args.push(ast.CallArg{
			expr = p.expr(0)
		})
		if p.tok.kind != .rpar {
			p.check(.comma)
		}
	}
	return args
}

fun (p Parser) enum_val(has_name bool) ast.EnumVal{
	pos := p.tok.pos
	mut name := ''
	if has_name {
		name = p.check_name()
		if p.expr_pkg.length > 0 {
			name = p.prepend_expr_pkg(name)
		} else {
			name = p.prepend_pkg(name)
		}
	}
	// typ := p.table.find_type_or_add_placeholder(name)
	p.check(.dot)
	val := p.check_name()
	return ast.EnumVal{
		name = name
		val = val
		// typ = typ
		pos = pos
	}
}

fun (p Parser) hash_expr()ast.Expr{
	p.check(.hash)
	p.check(.dot)
	if p.tok.kind != .string {
		p.expr_pkg = 'JS__'
		p.expr_pkg += p.check_name()
		p.check(.dot)
		return p.fun_call(.js)
	}

	str_node := p.string_literal() as ast.StringLiteral
	return ast.HashExpr{
		val = str_node.val
		pos = str_node.pos
	}
}

fun (p Parser) ident()ast.Ident{
	pos := p.tok.pos
	mut is_mut := p.tok.kind == .key_mut
	if is_mut {
		p.next()
	}
	if p.is_for_init {
		is_mut = true
	}
	name := p.prepend_expr_pkg(p.check_name())
	return ast.Ident{
		name = name
		is_mut = is_mut
		pkg = p.pkg_name
		pos = pos
	}
}

fun (p Parser) if_expr()ast.IfExpr{
	pos := p.tok.pos
	mut branches := []ast.IfBranch
	mut has_else := false
	for true {
		bpos := p.tok.pos
		if p.tok.kind == .key_else{
			p.next()
			if p.tok.kind == .lcur{
				has_else = true
				stmts := p.parse_block()
				branches.push(ast.IfBranch{
					cond = ast.EmptyExpr{}
					stmts = stmts
					pos = bpos
				})
				break
			}
		}
		p.check(.key_if)
		p.is_struct_possible = false
		cond := p.expr(0)
		p.is_struct_possible = true
		stmts := p.parse_block()
		branches.push(ast.IfBranch{cond = cond stmts = stmts})
		if p.tok.kind != .key_else{
			break
		}
	}
	return ast.IfExpr{
		has_else = has_else
		branches = branches
		pos = pos
	}
}

fun (p Parser) index_expr(left ast.Expr)ast.IndexExpr {
	pos := p.tok.pos
	p.check(.lbr)
	index := p.expr(0)
	p.check(.rbr)
	return ast.IndexExpr{
		left = left
		index = index
		pos = pos
	}
}

fun (p Parser) infix_expr(left ast.Expr)ast.InfixExpr{
	pos := p.tok.pos
	op_tok := p.tok
	p.next()
	right := p.expr(op_tok.precedence() as i32)
	return ast.InfixExpr{
		left = left
		right = right
		op = op_tok.kind
		pos = pos
	}
}

fun (p Parser) map_init() ast.MapInit{
	pos := p.tok.pos
	p.next()
	if p.tok.kind == .lbr{
		map_type := p.parse_map_type()
		return ast.MapInit{
			typ = map_type
			pos = pos
		}
	}
	mut keys := []ast.Expr
	mut vals := []ast.Expr
	p.check(.lcur)
	for p.tok.kind != .rcur {
		keys.push(p.expr(0))
		p.check(.colon)
		vals.push(p.expr(0))
	}
	p.next()
	return ast.MapInit{
		keys = keys
		vals = vals
		pos = pos
	}
}

fun (p Parser) match_expr()ast.MatchExpr{
	pos := p.tok.pos
	mut branches := []ast.MatchBranch
	p.check(.key_match)
	p.is_struct_possible = false
	cond := p.expr(0)
	p.is_struct_possible = true
	p.check(.lcur)
	for p.tok.kind != .rcur {
		bpos := p.tok.pos
		mut exprs := []ast.Expr
		if p.tok.kind == .key_else {
			p.next()
		} else {
			p.is_struct_possible = false
			exprs = p.expr_list()
			p.is_struct_possible = true
		}
		stmts := p.parse_block()
		branches.push(ast.MatchBranch{
			exprs = exprs
			stmts = stmts
			pos = pos
		})
	}
	p.check(.rcur)
	return ast.MatchExpr{
		cond = cond
		branches = branches
		pos = pos
	}
}

fun (p Parser) name_expr()ast.Expr{
	if p.next_tok.kind == .dot and p.import_aliases.contains(p.tok.val) {
		p.expr_pkg = p.import_aliases[p.tok.val]
		p.next()
		p.next()
	}
	if p.tok.val == 'map' {
		return p.map_init()
	}
	if p.next_tok.kind == .lpar {
		return p.fun_call(.bait)
	}
	if p.is_struct_possible and p.next_tok.kind == .lcur {
		return p.struct_init()
	}
	if p.next_tok.kind == .dot and p.tok.val[0].is_capital() and not p.tok.val.is_upper() {
		return p.enum_val(true)
	}
	return p.ident()
}

fun (p Parser) number_literal()ast.IntegerLiteral{
	pos := p.tok.pos
	p.next()
	return ast.IntegerLiteral{
		val = p.prev_tok.val
		pos = pos
	}
}

fun (p Parser) par_expr() ast.ParExpr {
	pos := p.tok.pos
	p.next()
	expr := p.expr(0)
	p.check(.rpar)
	return ast.ParExpr{
		expr = expr
		pos = pos
	}
}

fun (p Parser) prefix_expr()ast.PrefixExpr{
	pos := p.tok.pos
	op := p.tok.kind
	p.next()
	right := p.expr(0)
	return ast.PrefixExpr{
		op = op
		right = right
		pos = pos
	}
}

fun (p Parser) string_literal()ast.Expr{
	pos := p.tok.pos
	if p.next_tok.kind != .dollar {
		p.next()
		return ast.StringLiteral{
			val = p.prev_tok.val
			pos = pos
		}
	}
	mut vals := []string
	mut exprs := []ast.Expr
	for p.tok.kind == .string {
		vals.push(p.tok.val)
		p.next()
		if p.tok.kind != .dollar {
			break
		}
		p.next()
		p.check(.lcur)
		exprs.push(p.expr(0))
	}
	return ast.StringInterLiteral{
		vals = vals
		exprs = exprs
		pos = pos
	}
}

fun (p Parser) typeof_expr() ast.TypeOf {
	pos := p.tok.pos
	p.check(.key_typeof)
	p.check(.lpar)
	expr := p.expr(0)
	p.check(.rpar)
	return ast.TypeOf{
		expr = expr
		pos = pos
	}
}
