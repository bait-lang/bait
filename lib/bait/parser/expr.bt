// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (p Parser) expr(precedence i32) ast.Expr {
	mut node := ast.EmptyExpr{} as ast.Expr
	match p.tok.kind {
		token.TokenKind.hash {
			node = p.hash_expr()
		}
		token.TokenKind.char {
			node = p.char_literal()
		}
		token.TokenKind.dollar {
			node = p.comp_time_var()
		}
		token.TokenKind.dot {
			node = p.enum_val(false)
		}
		token.TokenKind.lbr {
			node = p.array_init()
		}
		token.TokenKind.lpar {
			node = p.par_expr()
		}
		token.TokenKind.name {
			node = p.name_expr('bait')
		}
		token.TokenKind.number {
			node = p.number_literal()
		}
		token.TokenKind.string {
			node = p.string_literal("bait")
		}
		token.TokenKind.key_fun {
			node = p.anon_fun()
		}
		token.TokenKind.key_false, token.TokenKind.key_true {
			node = p.bool_literal()
		}
		token.TokenKind.key_if {
			node = p.if_expr()
		}
		token.TokenKind.key_match {
			node = p.match_expr()
		}
		token.TokenKind.key_mut {
			node = p.ident('bait')
		}
		token.TokenKind.key_not, token.TokenKind.minus {
			node = p.prefix_expr()
		}
		token.TokenKind.key_typeof {
			node = p.typeof_expr()
		}
		else {
			p.error('invalid expression: ${p.tok.kind}, val: ${p.tok.val}')
		}
	}
	return p.expr_with_left(node, precedence)
}

fun (p Parser) expr_with_left(left any, precedence i32) ast.Expr {
	for precedence < p.tok.precedence() {
		if p.tok.kind == token.TokenKind.dot {
			left = p.dot_expr(left)
		} else if p.tok.kind == token.TokenKind.lbr {
			left = p.index_expr(left)
		} else if p.tok.kind == token.TokenKind.key_as {
			left = p.as_cast(left)
		} else if p.tok.kind.is_infix() {
			left = p.infix_expr(left)
		} else {
			return left
		}
	}
	return left
}

fun (p Parser) expr_list() []ast.Expr{
	mut exprs := []ast.Expr
	for true {
		exprs.push(p.expr(0))
		if p.tok.kind != token.TokenKind.comma {
			break
		}
		p.check(token.TokenKind.comma)
	}
	return exprs
}

fun (p Parser) anon_fun()ast.AnonFun{
	pos := p.tok.pos
	p.check(token.TokenKind.key_fun)
	p.check(token.TokenKind.lpar)
	params := p.fun_params()
	p.check(token.TokenKind.rpar)
	mut return_type := ast.VOID_TYPE
	if p.tok.kind != token.TokenKind.lcur {
		return_type = p.parse_type()
	}
	mut param_types := []ast.Type
	for param in params {
		param_types.push(param.typ)
	}
	typ := p.table.find_or_register_fun(param_types, return_type)
	stmts := p.parse_block()
	return ast.AnonFun{
		decl: ast.FunDecl{
			params: params
			return_type: return_type
			stmts: stmts
		}
		typ: typ
		pos: pos
	}
}

fun (p Parser) array_init()ast.ArrayInit{
	mut exprs := []ast.Expr
	mut elem_type := ast.PLACEHOLDER_TYPE
	mut typ := ast.ARRAY_TYPE
	pos := p.tok.pos
	p.check(token.TokenKind.lbr)
	if p.tok.kind == token.TokenKind.rbr {
		p.next()
		elem_type = p.parse_type()
		typ = p.table.find_or_register_array(elem_type)
	} else {
		for p.tok.kind != token.TokenKind.rbr {
			exprs.push(p.expr(0))
			if p.tok.kind == token.TokenKind.comma {
				p.next()
			}
		}
		p.check(token.TokenKind.rbr)
	}
	return ast.ArrayInit{
		exprs: exprs
		typ: typ
		elem_type: elem_type
		pos: pos
	}
}

fun (p Parser) as_cast(left ast.Expr) ast.AsCast {
	pos := p.tok.pos
	p.check(token.TokenKind.key_as)
	target := p.parse_type()
	return ast.AsCast{
		target: target
		expr: left
		pos: pos
	}
}

fun (p Parser) bool_literal()ast.BoolLiteral{
	pos := p.tok.pos
	val := p.tok.kind == token.TokenKind.key_true
	p.next()
	return ast.BoolLiteral{
		val: val
		pos: pos
	}
}

fun (p Parser) char_literal()ast.CharLiteral{
	pos := p.tok.pos
	p.next()
	return ast.CharLiteral{
		val: p.prev_tok.val
		pos: pos
	}
}

fun (p Parser) comp_time_var() ast.CompTimeVar{
	pos := p.tok.pos
	p.next()
	name := p.check_name()
	return ast.CompTimeVar{
		name: name
		pos: pos
	}
}

fun (p Parser) dot_expr(left ast.Expr) ast.Expr {
	pos := p.tok.pos
	p.check(token.TokenKind.dot)
	if p.next_tok.kind == token.TokenKind.lpar {
		return p.method_call(left)
	}
	name := p.check_name()
	return ast.SelectorExpr{
		expr: left
		field_name: name
		pos: pos
	}
}

fun (p Parser) fun_call(lang string)ast.CallExpr{
	pos := p.tok.pos
	name := p.prepend_expr_pkg(p.check_name())
	p.check(token.TokenKind.lpar)
	args := p.call_args()
	p.check(token.TokenKind.rpar)
	return ast.CallExpr{
		name: name
		args: args
		lang: lang
		pkg: p.pkg_name
		pos: pos
	}
}

fun (p Parser) method_call(left ast.Expr) ast.CallExpr {
	pos := p.tok.pos
	name := p.check_name()
	p.check(token.TokenKind.lpar)
	args := p.call_args()
	p.check(token.TokenKind.rpar)
	return ast.CallExpr{
		is_method: true
		left: left
		name: name
		args: args
		lang: 'bait'
		pos: pos
	}
}

fun (p Parser) call_args() []ast.CallArg {
	mut args := []ast.CallArg
	for p.tok.kind != token.TokenKind.rpar {
		args.push(ast.CallArg{
			expr: p.expr(0)
		})
		if p.tok.kind != token.TokenKind.rpar {
			p.check(token.TokenKind.comma)
		}
	}
	return args
}

fun (p Parser) enum_val(has_name bool) ast.EnumVal{
	pos := p.tok.pos
	mut name := ''
	if has_name {
		name = p.check_name()
		if p.expr_pkg.length > 0 {
			name = p.prepend_expr_pkg(name)
		} else {
			name = p.prepend_pkg(name)
		}
	}
	// typ := p.table.find_type_or_add_placeholder(name)
	p.check(token.TokenKind.dot)
	val := p.check_name()
	return ast.EnumVal{
		name: name
		val: val
		// typ: typ
		pos: pos
	}
}

fun (p Parser) hash_expr()ast.Expr{
	p.check(token.TokenKind.hash)
	p.check(token.TokenKind.dot)
	if p.tok.kind == token.TokenKind.string {
		return p.string_literal('js')
	}
	return p.name_expr('js')
}

fun (p Parser) ident(lang string)ast.Ident{
	pos := p.tok.pos
	mut is_mut := p.tok.kind == token.TokenKind.key_mut
	if is_mut {
		p.next()
	}
	if p.is_for_init {
		is_mut = true
	}
	name := p.prepend_expr_pkg(p.check_name())
	return ast.Ident{
		name: name
		is_mut: is_mut
		pkg: p.pkg_name
		lang: lang
		pos: pos
	}
}

fun (p Parser) if_expr()ast.IfExpr{
	pos := p.tok.pos
	mut branches := []ast.IfBranch
	mut has_else := false
	for true {
		bpos := p.tok.pos
		if p.tok.kind == token.TokenKind.key_else{
			p.next()
			if p.tok.kind == token.TokenKind.lcur{
				has_else = true
				stmts := p.parse_block()
				branches.push(ast.IfBranch{
					cond: ast.EmptyExpr{}
					stmts: stmts
					pos: bpos
				})
				break
			}
		}
		p.check(token.TokenKind.key_if)
		p.is_struct_possible = false
		cond := p.expr(0)
		p.is_struct_possible = true
		stmts := p.parse_block()
		branches.push(ast.IfBranch{cond: cond stmts: stmts})
		if p.tok.kind != token.TokenKind.key_else{
			break
		}
	}
	return ast.IfExpr{
		has_else: has_else
		branches: branches
		pos: pos
	}
}

fun (p Parser) index_expr(left ast.Expr)ast.IndexExpr {
	pos := p.tok.pos
	p.check(token.TokenKind.lbr)
	index := p.expr(0)
	p.check(token.TokenKind.rbr)
	return ast.IndexExpr{
		left:left
		index: index
		pos: pos
	}
}

fun (p Parser) infix_expr(left ast.Expr)ast.InfixExpr{
	pos := p.tok.pos
	op_tok := p.tok
	p.next()
	right := p.expr(op_tok.precedence())
	return ast.InfixExpr{
		left:left
		right: right
		op: op_tok.kind
		pos: pos
	}
}

fun (p Parser) map_init() ast.MapInit{
	pos := p.tok.pos
	p.next()
	if p.tok.kind == token.TokenKind.lbr{
		map_type := p.parse_map_type()
		return ast.MapInit{
			typ: map_type
			pos: pos
		}
	}
	mut keys := []ast.Expr
	mut vals := []ast.Expr
	p.check(token.TokenKind.lcur)
	for p.tok.kind != token.TokenKind.rcur {
		keys.push(p.expr(0))
		p.check(token.TokenKind.colon)
		vals.push(p.expr(0))
	}
	p.next()
	return ast.MapInit{
		keys: keys
		vals: vals
		pos: pos
	}
}

fun (p Parser) match_expr()ast.MatchExpr{
	pos := p.tok.pos
	mut branches := []ast.MatchBranch
	p.check(token.TokenKind.key_match)
	p.is_struct_possible = false
	cond := p.expr(0)
	p.is_struct_possible = true
	p.check(token.TokenKind.lcur)
	for p.tok.kind != token.TokenKind.rcur {
		bpos := p.tok.pos
		mut exprs := []ast.Expr
		if p.tok.kind == token.TokenKind.key_else {
			p.next()
		} else {
			p.is_struct_possible = false
			exprs = p.expr_list()
			p.is_struct_possible = true
		}
		stmts := p.parse_block()
		branches.push(ast.MatchBranch{
			exprs: exprs
			stmts: stmts
			pos: pos
		})
	}
	p.check(token.TokenKind.rcur)
	return ast.MatchExpr{
		cond:cond
		branches: branches
		pos: pos
	}
}

fun (p Parser) name_expr(lang string)ast.Expr{
	if p.next_tok.kind == token.TokenKind.dot and p.import_aliases.contains(p.tok.val) {
		p.expr_pkg = p.import_aliases[p.tok.val]
		p.next()
		p.next()
	}
	if p.tok.val == 'map' {
		return p.map_init()
	}
	if p.next_tok.kind == token.TokenKind.lpar {
		return p.fun_call(lang)
	}
	if p.is_struct_possible and p.next_tok.kind == token.TokenKind.lcur {
		return p.struct_init()
	}
	if p.next_tok.kind == token.TokenKind.dot and p.tok.val[0].is_capital() and not p.tok.val.is_upper() {
		return p.enum_val(true)
	}
	return p.ident(lang)
}

fun (p Parser) number_literal()ast.IntegerLiteral{
	pos := p.tok.pos
	p.next()
	return ast.IntegerLiteral{
		val: p.prev_tok.val
		pos: pos
	}
}

fun (p Parser) par_expr() ast.ParExpr {
	pos := p.tok.pos
	p.next()
	expr := p.expr(0)
	p.check(token.TokenKind.rpar)
	return ast.ParExpr{
		expr: expr
		pos: pos
	}
}

fun (p Parser) prefix_expr()ast.PrefixExpr{
	pos := p.tok.pos
	op := p.tok.kind
	p.next()
	right := p.expr(0)
	return ast.PrefixExpr{
		op: op
		right: right
		pos: pos
	}
}

fun (p Parser) string_literal(lang string)ast.Expr{
	pos := p.tok.pos
	if p.next_tok.kind != token.TokenKind.dollar {
		p.next()
		return ast.StringLiteral{
			val:p.prev_tok.val
			lang:lang
			pos: pos
		}
	}
	mut vals := []string
	mut exprs := []ast.Expr
	for p.tok.kind == token.TokenKind.string {
		vals.push(p.tok.val)
		p.next()
		if p.tok.kind != token.TokenKind.dollar {
			break
		}
		p.next()
		p.check(token.TokenKind.lcur)
		exprs.push(p.expr(0))
	}
	return ast.StringInterLiteral{
		vals:vals
		exprs:exprs
		pos: pos
	}
}

fun (p Parser) struct_init()ast.StructInit{
	pos := p.tok.pos
	typ := p.parse_type()
	name := p.prev_tok.val
	p.check(token.TokenKind.lcur)
	mut fields := []ast.StructInitField
	for p.tok.kind != token.TokenKind.rcur {
		fpos := p.tok.pos
		fname := p.check_name()
		p.check(token.TokenKind.colon)
		expr := p.expr(0)
		fields.push(ast.StructInitField{
			name: fname
			expr: expr
			pos: fpos
		})
	}
	p.check(token.TokenKind.rcur)
	return ast.StructInit{
		name: name
		typ: typ
		fields: fields
		pos: pos
	}
}

fun (p Parser) typeof_expr() ast.TypeOf {
	pos := p.tok.pos
	p.check(token.TokenKind.key_typeof)
	p.check(token.TokenKind.lpar)
	expr := p.expr(0)
	p.check(token.TokenKind.rpar)
	return ast.TypeOf{
		expr: expr
		pos: pos
	}
}
