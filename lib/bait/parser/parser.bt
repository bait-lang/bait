// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.preference
import bait.errors
import bait.ast
import bait.token

pub struct Parser {
	pref preference.Prefs
	path string
	table ast.Table
	tokens []token.Token
mut:
	eofs i32
	idx i32
	prev_tok token.Token
	tok token.Token
	next_tok token.Token
	pkg_name string
	import_aliases map[string]string
	attributes []ast.Attribute
	expr_pkg string
	is_for_init bool
	is_struct_possible bool
	should_abort bool
pub mut:
	warnings []errors.Message
	errors []errors.Message
}

pub fun parse(tokens []token.Token, path string, table ast.Table, pref preference.Prefs) ast.File {
	mut p := Parser{
		pref = pref
		path = path
		table = table
		tokens = tokens
		is_struct_possible = true
	}

	p.next()
	p.next()

	pkg_decl := p.package_decl()

	// Validate the files package name actually matches the desired import
	if p.pref.expected_pkg.length > 0 and pkg_decl.full_name != p.pref.expected_pkg {
		return ast.File{
			path = path
		}
	}

	imports := p.import_stmts()

	mut stmts := []ast.Stmt
	for p.tok.kind != .eof {
		p.parse_attributes()
		stmts.push(p.toplevel_stmt())
		if p.should_abort {
			break
		}
	}

	return ast.File{
		path = path
		pkg_decl = pkg_decl
		imports = imports
		stmts = stmts
		warnings = p.warnings
		errors = p.errors
	}
}

fun (mut p Parser) package_decl() ast.PackageDecl {
	if p.tok.kind != .key_package {
		p.pkg_name = "main"
		return ast.PackageDecl{
			name = "main"
			full_name = "main"
		}
	}
	p.next()
	name := p.check_name()
	mut full_name := name
	if full_name != 'main' and p.path.contains('lib/') {
		rel_path := p.path.substr(p.path.index('lib/') + 4, p.path.length)
		full_name = rel_path.substr(0, rel_path.last_index('/')).replace('/', '.')
	}
	p.pkg_name = full_name
	return ast.PackageDecl{
		name = name
		full_name = full_name
	}
}

// Parses one or more attributes
fun (mut p Parser) parse_attributes() {
	for p.tok.kind == .attr {
		pos := p.tok.pos
		name := p.tok.val
		p.next()
		mut value := ''
		if p.tok.kind == .colon {
			p.next()
			p.check(.string)
			value = p.prev_tok.val
		}
		p.attributes.push(ast.Attribute{
			name = name
			value = value
			pos = pos
		})
	}
}

fun (mut p Parser) parse_block() []ast.Stmt {
	p.check(.lcur)
	mut bstmts := []ast.Stmt
	for not [token.TokenKind.eof, .rcur].contains(p.tok.kind) {
		bstmts.push(p.stmt())
		if p.should_abort {
			break
		}
	}
	p.check(.rcur)
	return bstmts
}

fun (mut p Parser) check (expected token.TokenKind) {
	if p.tok.kind != expected {
		p.error('unexpected ${p.tok.kind}, expecting ${expected}')
	}
	p.next()
}

fun (mut p Parser) check_name() string {
	p.check(.name)
	return p.prev_tok.val
}

fun (mut p Parser) check_pub() bool {
	if p.tok.kind == .key_pub {
		p.next()
		return true
	}
	return false
}

fun (mut p Parser) parse_lang() ast.Language {
	if p.tok.kind != .hash {
		return .bait
	}
	lang := ast.prefix_to_lang(p.tok.val)
	p.next()
	p.check(.dot)
	return lang
}

fun (p Parser) prepend_pkg(val string) string {
	if p.pkg_name == 'builtin' or p.pkg_name == 'main' or p.pkg_name.length == 0{
		return val
	}
	return p.pkg_name + '.' + val
}

fun (mut p Parser) prepend_expr_pkg(val string) string {
	if p.expr_pkg.length == 0 or p.expr_pkg == p.pkg_name {
		return val
	}
	res := p.expr_pkg + '.' + val
	p.expr_pkg = ''
	return res
}

fun (mut p Parser) next() {
	p.prev_tok = p.tok
	p.tok = p.next_tok
	if p.idx < p.tokens.length {
		p.next_tok = p.tokens[p.idx]
		p.idx += 1
	} else {
		p.eofs += 1
		if p.eofs > 10 {
			panic('parser is stuck at end of file ${p.path}')
		}
		p.next_tok = p.tokens.last()
	}
}

fun (p Parser) warn(msg string) {
	p.warnings.push(errors.Message{
		kind = .warning
		path = p.path
		pos = p.tok.pos
		title = 'warning'
		msg = msg
	})
}

fun (mut p Parser) error(msg string){
	p.errors.push(errors.Message{
		kind = .error
		path = p.path
		pos = p.tok.pos
		title = 'error'
		msg = msg
	})
	p.should_abort = true
}
