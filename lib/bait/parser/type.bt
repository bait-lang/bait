// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (p Parser) parse_type() ast.Type {
	if p.tok.kind == .lbr{
		p.next()
		p.check(.rbr)
		elem_type := p.parse_type()
		return p.table.find_or_register_array(elem_type)
	}
	if p.tok.kind == .key_fun {
		return p.parse_fun_type()
	}
	lang := p.parse_lang()
	mut name := p.prepend_lang(lang, p.check_name())
	if name == 'map' {
		return p.parse_map_type()
	}
	if p.tok.kind == .dot {
		pkg := p.import_aliases[name]
		p.next()
		name = pkg + '.' + p.check_name()
	} else if p.expr_pkg.length > 0 {
		name = p.prepend_expr_pkg(name)
	} else if not name.contains('.') and not p.table.type_idxs.contains(name) {
		name = p.prepend_pkg(name)
	}
	match name{
		'i8' { return ast.I8_TYPE }
		'i16' { return ast.I16_TYPE }
		'i32' { return ast.I32_TYPE }
		'i64' { return ast.I64_TYPE }
		'u8' { return ast.U8_TYPE }
		'u16' { return ast.U16_TYPE }
		'u32' { return ast.U32_TYPE }
		'u64' { return ast.U64_TYPE }
		'f32' { return ast.F32_TYPE }
		'f64' { return ast.F64_TYPE }
		'bool' { return ast.BOOL_TYPE }
		'string' { return ast.STRING_TYPE }
		'any' { return ast.ANY_TYPE }
	}
	return p.table.find_type_or_add_placeholder(name)
}

fun (p Parser) parse_fun_type() ast.Type {
	p.next()
	p.check(.lpar)
	mut param_types := []ast.Type
	for p.tok.kind != .rpar{
		typ := p.parse_type()
		param_types.push(typ)
		if p.tok.kind != .rpar{
			p.check(.comma)
		}
	}
	p.check(.rpar)
	mut return_type := ast.VOID_TYPE
	if p.tok.pos.line == p.prev_tok.pos.line {
		return_type = p.parse_type()
	}
	return p.table.find_or_register_fun(param_types, return_type)
}

fun (p Parser) parse_map_type() ast.Type {
	if p.tok.kind == .rpar and p.pkg_name == 'builtin' {
		return ast.MAP_TYPE
	}
	p.check(.lbr)
	key_type := p.parse_type()
	if key_type != ast.STRING_TYPE {
		p.error('map key type must be string')
	}
	p.check(.rbr)
	val_type := p.parse_type()
	return p.table.find_or_register_map(key_type, val_type)
}

fun (p Parser) infer_expr_type(expr ast.Expr) ast.Type {
	match expr {
		ast.BoolLiteral{ return ast.BOOL_TYPE }
		ast.CharLiteral{ return ast.U8_TYPE }
		ast.IntegerLiteral{ return ast.I32_TYPE }
		ast.StringLiteral{ return ast.STRING_TYPE }
		ast.StructInit{ return expr.typ }
		ast.ArrayInit{ return expr.typ }
		ast.MapInit{ return expr.typ }
	}
	return ast.VOID_TYPE
}
