// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (p Parser) parse_type() i32 {
	if p.tok.kind == token.TokenKind.lbr{
		p.next()
		p.check(token.TokenKind.rbr)
		elem_type := p.parse_type()
		return p.table.find_or_register_array(elem_type)
	}
	if p.tok.kind == token.TokenKind.key_fun {
		return p.parse_fun_type()
	}
	mut name := p.check_name()
	if name == 'map' {
		return p.parse_map_type()
	}
	if p.tok.kind == token.TokenKind.dot {
		pkg := p.import_aliases[name]
		p.next()
		name = pkg + '.' + p.check_name()
	} else if p.expr_pkg.length > 0 {
		name = p.prepend_expr_pkg(name)
	} else if not name.contains('.') and not p.table.type_idxs.contains(name) {
		name = p.prepend_pkg(name)
	}
	match name{
		'i8' { return ast.TypeIdx.i8 }
		'i16' { return ast.TypeIdx.i16 }
		'i32' { return ast.TypeIdx.i32 }
		'i64' { return ast.TypeIdx.i64 }
		'u8' { return ast.TypeIdx.u8 }
		'u16' { return ast.TypeIdx.u16 }
		'u32' { return ast.TypeIdx.u32 }
		'u64' { return ast.TypeIdx.u64 }
		'f32' { return ast.TypeIdx.f32 }
		'f64' { return ast.TypeIdx.f64 }
		'bool' { return ast.TypeIdx.bool }
		'string' { return ast.TypeIdx.string }
		'any' { return ast.TypeIdx.any }
	}
	return p.table.find_type_or_add_placeholder(name)
}

fun (p Parser) parse_fun_type() i32 {
	p.next()
	p.check(token.TokenKind.lpar)
	mut param_types := []i32
	for p.tok.kind != token.TokenKind.rpar{
		typ := p.parse_type()
		param_types.push(typ)
		if p.tok.kind != token.TokenKind.rpar{
			p.check(token.TokenKind.comma)
		}
	}
	p.check(token.TokenKind.rpar)
	mut return_type := ast.TypeIdx.void as i32
	if p.tok.pos.line == p.prev_tok.pos.line {
		return_type = p.parse_type()
	}
	return p.table.find_or_register_fun(param_types, return_type)
}

fun (p Parser) parse_map_type() i32 {
	if p.tok.kind == token.TokenKind.rpar and p.pkg_name == 'builtin' {
		return ast.TypeIdx.map
	}
	p.check(token.TokenKind.lbr)
	key_type := p.parse_type()
	if key_type != ast.TypeIdx.string as i32 {
		p.error('map key type must be string')
	}
	p.check(token.TokenKind.rbr)
	val_type := p.parse_type()
	return p.table.find_or_register_map(key_type, val_type)
}

fun (p Parser) infer_expr_type(expr ast.Expr) i32 {
	match expr {
		ast.BoolLiteral{ return ast.TypeIdx.bool as i32 }
		ast.CharLiteral{ return ast.TypeIdx.u8 as i32 }
		ast.IntegerLiteral{ return ast.TypeIdx.i32 as i32 }
		ast.StringLiteral{ return ast.TypeIdx.string as i32 }
		ast.StructInit{ return expr.typ }
		ast.ArrayInit{ return expr.typ }
		ast.MapInit{ return expr.typ }
	}
	return ast.TypeIdx.placeholder as i32
}
