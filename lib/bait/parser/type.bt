// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code Form is subject to the terms of the Mozilla Public License 2.0.
package parser

import bait.ast
import bait.token

fun (p Parser) parse_type() ast.Type {
	// Pointers
	mut nr_amp := 0
	for p.tok.kind == .amp{
		p.next()
		nr_amp += 1
	}

	// Array type
	if p.tok.kind == .lbr{
		p.next()
		p.check(.rbr)
		elem_type := p.parse_type()
		return p.table.find_or_register_array(elem_type)
	}

	// Function type
	if p.tok.kind == .key_fun {
		return p.parse_fun_type()
	}

	lang := p.parse_lang()

	// Return placeholder or get name. Used for typeless array inits where type is known
	if p.tok.pos.line != p.prev_tok.pos.line {
		return ast.PLACEHOLDER_TYPE
	}
	mut name := lang.prepend_to(p.check_name())

	// Map type
	if name == 'map' {
		return p.parse_map_type()
	}

	// Build full name and handle imported types
	if p.tok.kind == .dot {
		pkg := p.import_aliases[name]
		p.next()
		name = pkg + '.' + p.check_name()
	} else if p.expr_pkg.length > 0 {
		name = p.prepend_expr_pkg(name)
	} else if not name.contains('.') and not p.table.type_idxs.contains(name) {
		name = p.prepend_pkg(name)
	}

	// Primitive types
	mut typ := ast.PLACEHOLDER_TYPE
	match name{
		'i8' { typ = ast.I8_TYPE }
		'i16' { typ = ast.I16_TYPE }
		'i32' { typ = ast.I32_TYPE }
		'i64' { typ = ast.I64_TYPE }
		'u8' { typ = ast.U8_TYPE }
		'u16' { typ = ast.U16_TYPE }
		'u32' { typ = ast.U32_TYPE }
		'u64' { typ = ast.U64_TYPE }
		'f32' { typ = ast.F32_TYPE }
		'f64' { typ = ast.F64_TYPE }
		'bool' { typ = ast.BOOL_TYPE }
		'string' { typ = ast.STRING_TYPE }
		'any' { typ = ast.ANY_TYPE }
		else { typ = p.table.find_type_or_add_placeholder(name) }
	}
	if nr_amp > 0 {
		typ = typ.set_nr_amp(nr_amp)
	}
	return typ
}

fun (p Parser) parse_fun_type() ast.Type {
	p.next()
	p.check(.lpar)
	mut param_types := []ast.Type
	for p.tok.kind != .rpar{
		typ := p.parse_type()
		param_types.push(typ)
		if p.tok.kind != .rpar{
			p.check(.comma)
		}
	}
	p.check(.rpar)
	mut return_type := ast.VOID_TYPE
	if p.tok.pos.line == p.prev_tok.pos.line {
		return_type = p.parse_type()
	}
	return p.table.find_or_register_fun(param_types, return_type)
}

fun (p Parser) parse_map_type() ast.Type {
	if p.tok.kind == .rpar and p.pkg_name == 'builtin' {
		return ast.MAP_TYPE
	}
	p.check(.lbr)
	key_type := p.parse_type()
	if key_type != ast.STRING_TYPE {
		p.error('map key type must be string')
	}
	p.check(.rbr)
	val_type := p.parse_type()
	return p.table.find_or_register_map(key_type, val_type)
}

fun (p Parser) infer_expr_type(expr ast.Expr) ast.Type {
	match expr {
		ast.BoolLiteral{ return ast.BOOL_TYPE }
		ast.CharLiteral{ return ast.U8_TYPE }
		ast.IntegerLiteral{ return ast.I32_TYPE }
		ast.StringLiteral{ return ast.STRING_TYPE }
		ast.StructInit{ return expr.typ }
		ast.MapInit{ return expr.typ }
	}
	return ast.VOID_TYPE
}
