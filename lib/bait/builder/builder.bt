// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package builder

import os
import bait.ast
import bait.errors
import bait.parser
import bait.checker
import bait.gen.js as jsgen
import bait.gen.c as cgen
import bait.preference
import bait.util.timers

struct Builder {
mut:
	prefs preference.Prefs
	parsed_files []ast.File
	parsed_pkgs []string
	checker checker.Checker
	parser parser.Parser
}

// Returns the absolute paths to all bait files in a directory that should be compiled
fun (b Builder) bait_files_in_dir(dir string) []string {
	all_files := os.ls(dir)

	mut files := []string
	for f in all_files {
		if b.prefs.should_compile_file(f) {
			files.push(os.join_path(dir, [f]))
		}
	}

	return files
}

fun (b Builder) collect_user_files(path string) []string {
	if os.exists(path) {
		if  path.ends_with('.bt') {
			return [path]
		}

		if os.is_dir(path) {
			return b.bait_files_in_dir(path)
		}
	}

	return []string
}

fun (b Builder) parse_file(path string, pkg string) ast.File {
	text := os.read_file(path)
	return b.parser.parse(text, path, pkg)
}

pub fun compile(prefs preference.Prefs) i32 {
	mut b := Builder{
		prefs = prefs
		parser = parser.new(ast.new_table(), prefs)
	}

	// Collect files for compilation
	mut paths := b.collect_user_files(prefs.command)
	if paths.length == 0 {
		errors.generic_error('directory ${prefs.command} contains no Bait files')
		return 1
	}

	// Tokenize and parse files
	timers.start('PARSE')
	mut ast_files := []ast.File
	for p in paths {
		ast_files.push(b.parse_file(p, ''))
	}

	// Resolve and parse imports. New elements are dynamically added to `ast_files`
	for i := 0; i < ast_files.length; i += 1 {
		file := ast_files[i]

		for imp in file.imports {
			if imp.lang != .bait {
				continue
			}

			// Skip already parsed packages
			if b.parsed_pkgs.contains(imp.name) {
				// FIXME possible problem if two imports share the same name but would resolve to different paths
				continue
			}

			// Resolve import path
			import_dir := resolve_import(os.dir(file.path), imp.name)
			if not os.exists(import_dir) {
				errors.generic_error('package ${imp.name} not found')
				continue
			}

			// Collect files
			mut imp_paths := b.bait_files_in_dir(import_dir)
			if imp_paths.length == 0 {
				errors.generic_error('package ${imp.name} contains no Bait files')
				continue
			}

			// Parse files
			mut nr_newly_parsed := 0
			for p in imp_paths {
				parsed_file := b.parse_file(p, imp.name)

				if parsed_file.path.length == 0 {
					continue
				}

				nr_newly_parsed += 1
				paths.push(p)
				ast_files.push(parsed_file)
			}

			if nr_newly_parsed == 0 and imp_paths.length > 0 {
				errors.generic_error('no files belong to package ${imp.name}')
			}

			b.parsed_pkgs.push(imp.name)
		}
	}

	timers.show('PARSE')

	b.parsed_files = ast_files
	if b.print_errors_and_warnings(true) {
		return 1
	}

	// TODO move whole depgraph build and resolve into pkg

	timers.start('DEPGRAPH')
	// Build a dependency map for each file
	mut deps := map[string][]string
	for f in ast_files {
		pkg_name := f.pkg_decl.full_name

		for imp in f.imports {
			if imp.lang != .bait {
				continue
			}
			deps[pkg_name].push(imp.name)
		}
	}

	// Sort the packages, so type checking works properly
	mut looked := []string
	mut pkg_order := []string
	order_pkgs(pkg_order, ast_files[0].pkg_decl.full_name, deps, looked)
	mut sorted_files := []ast.File
	for pkg in pkg_order {
		for f in ast_files {
			if f.pkg_decl.full_name == pkg {
				sorted_files.push(f)
			}
		}
	}

	timers.show('DEPGRAPH')

	// Run the type resolver and checker
	timers.start('CHECK')
	b.parsed_files = sorted_files
	b.checker = checker.Checker{
		prefs = b.prefs
		table = b.parser.table
	}
	b.checker.check_files(sorted_files)
	timers.show('CHECK')

	if b.print_errors_and_warnings(false) {
		return 1
	}

	if b.prefs.backend == .c {
		return b.code_gen_c()
	}

	return b.code_gen_js()
}

fun (b Builder) code_gen_js() i32 {
	// Run JSGen and write it to the outfile
	timers.start('GEN')
	res := jsgen.gen(b.parsed_files, b.parser.table, b.prefs) + '\n'
	timers.show('GEN')
	ensure_dir_exists(os.dir(b.prefs.out_name))
	os.write_file(b.prefs.out_name, res)

	// Execute the resulting file with NodeJS if required
	if b.prefs.should_run{
		argstr := b.prefs.user_args.join(' ')
		run_res := os.system('node ${b.prefs.out_name} ${argstr}')
		if not b.prefs.keep_exe {
			os.rm(b.prefs.out_name)
		}
		return run_res
	}

	return 0
}

fun (mut b Builder) code_gen_c() i32 {
	timers.start('GEN')
	res := cgen.gen(b.parsed_files, b.parser.table, b.prefs) + '\n'
	timers.show('GEN')

	if os.exists_dir(b.prefs.out_name) or os.platform() == 'win32' {
		b.prefs.out_name += '.exe'
	}
	ensure_dir_exists(os.dir(b.prefs.out_name))

	tmp_c_path := os.join_path(os.tmp_dir(), [os.file_name(b.prefs.out_name) + '.c'])
	os.write_file(tmp_c_path, res)
	mut cflags := ''
	if b.prefs.is_library {
		cflags += '-shared -fPIC '
	}
	comp_res := os.system('${b.prefs.cc} ${tmp_c_path} ${cflags} -o ${b.prefs.out_name}')
	if comp_res != 0 {
		return comp_res
	}

	if b.prefs.should_run{
		argstr := b.prefs.user_args.join(' ')
		run_cmd := './${b.prefs.out_name} ${argstr}'.replace('/', os.PATH_SEP)
		run_res := os.system(run_cmd)
		if not b.prefs.keep_exe {
			os.rm(b.prefs.out_name)
		}
		return run_res
	}

	return 0
}

fun (b Builder) print_errors_and_warnings(parser_errs bool) bool {
	mut nr_warns := 0
	mut nr_errors := 0

	for f in b.parsed_files {
		nr_warns += f.warnings.length
		nr_errors += f.errors.length

		// -w hides info messages too
		if not b.prefs.hide_warnings {
			for info in f.infos {
				info.print()
			}
		}

		if b.prefs.warn_is_error {
			for warn in f.warnings {
				errors.error(warn.path, warn.pos, warn.msg)
			}
		} else if not b.prefs.hide_warnings {
			for warn in f.warnings {
				warn.print()
			}
		}

		for err in f.errors {
			err.print()
			if parser_errs {
				return true
			}
		}
	}

	nr_errors += b.checker.errors.length
	for err in b.checker.errors {
		err.print()
	}

	return nr_errors > 0 or (b.prefs.warn_is_error and nr_warns > 0)
}

// Resolve an import to absolute file path
fun resolve_import(base_dir string, name string) string {
	name_as_path := name.replace('.', os.PATH_SEP)

	// Search next to the current file
	mut dir := os.join_path(base_dir, [name_as_path])
	if os.exists(dir) {
		return dir
	}

	// Search in std lib
	dir = os.resource_abs_path(os.join_path("lib", [name_as_path]))
	if os.exists(dir) {
		return dir
	}

	// When running make, lib is in the working dir
	return os.join_path(os.getwd(), ["lib", name_as_path])
}

fun order_pkgs(mut ordered []string, pkg string, deps map[string][]string, mut looked []string) {
	looked.push(pkg)
	for d in deps[pkg] {
		if looked.contains(d) {
			// TODO warn on cyclic deps
			continue
		}
		order_pkgs(ordered, d, deps, looked)
	}
	if not ordered.contains(pkg) {
		ordered.push(pkg)
	}
}

fun ensure_dir_exists(dir string) {
	if not os.exists(dir) {
		os.mkdir(dir)
	}
}
