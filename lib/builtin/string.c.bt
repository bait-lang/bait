// SPDX-FileCopyrightText: 2023-present Lukas Neubert <lukas.neubert@proton.me>
// SPDX-License-Identifier: MPL-2.0
package builtin

import strings

struct string {
pub mut:
	str &u8
	length i32
}

fun (s string) get(i i32) u8 {
	return s.str[i]
}

pub fun (s string) substr(start i32, end i32) string {
	length := end - start
	mut res := string{
		str = #C.calloc(1, length + 1)
		length = length
	}
	#C.memcpy(res.str, #C.'s.str + start', length)
	res.str[length] = 0 as u8
	return res
}

pub fun (s string) trim_left(cutset string) string {
	mut pos := 0
	for pos < s.length {
		mut found := false
		for c in cutset {
			if s[pos] == c {
				found = true
				break
			}
		}

		if not found {
			break
		}

		pos += 1
	}

	return s.substr(pos, s.length)
}

pub fun (s string) trim_right(cutset string) string {
	mut pos := s.length - 1
	for pos >= 0 {
		mut found := false
		for c in cutset {
			if s[pos] == c {
				found = true
				break
			}
		}

		if not found {
			break
		}

		pos -= 1
	}

	return s.substr(0, pos + 1)
}

pub fun (s string) repeat(count i32) string {
	if count == 0 {
		return ''
	}

	if count == 1 {
		return s
	}

	mut buf := #C.calloc(1, s.length * count + 1)
	for i := 0; i < count; i += 1 {
		#C.memcpy(#C.'buf + i * s.length', s.str, s.length)
	}

	new_len := s.length * count
	buf[new_len] = 0 as u8

	return string{
		str = buf
		length = new_len
	}
}

@overload: '+'
fun (a string) add (b string) string {
	new_len := a.length + b.length
	res := string{
		str = #C.calloc(1, new_len + 1)
		length = new_len
	}
	for i:=0; i < a.length; i+=1 {
		res.str[i] = a.str[i]
	}
	for i:=0; i < b.length; i+=1 {
		res.str[a.length + i] = b.str[i]
	}
	res.str[new_len] = 0 as u8
	return res
}

@overload: '=='
fun (a string) eq (b string) bool {
	if a.length != b.length {
		return false
	}

	for i := 0; i < a.length; i += 1 {
		if a.str[i] != b.str[i] {
			return false
		}
	}
	return true
}

pub fun from_c_string(cs &u8) string {
	return string{
		str = cs
		length = #C.strlen(cs)
	}
}

fun interpolate(strs []string) string {
	mut b := strings.new_builder(100)
	for s in strs {
		b.write(s)
	}
	return b.str()
}
