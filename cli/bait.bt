// Copyright (c) 2023-present Lukas Neubert and contributors (see AUTHORS.md).
// This Source Code is subject to the terms of the Mozilla Public License 2.0.
package main

import bait.preference
import bait.ast
import bait.builder
import bait.tokenizer
import bait.parser
import bait.checker
import bait.gen.js as jsgen
import bait.util
import os

const TOOLS := [
	'ast',
	'self',
	'up',
	'doctor',
	'help',
	'test-all',
	'test-self',
	'build-examples',
	'build-tools',
	'check-md',
	'gen-baitjs',
]

fun ensure_dir_exists(dir string) {
	if not os.exists(dir) {
		os.mkdir(dir)
	}
}

fun run_tests(prefs preference.Prefs) i32 {
	mut files_to_test := []string
	for a in prefs.args {
		if os.exists(a) and a.ends_with('_test.bt') {
			files_to_test.push(a)
		} else if os.is_dir(a){
			files_to_test = files_to_test.concat(os.walk_ext(a, '_test.bt'))
		} else {
			eprintln('Unrecognized file or directory: "${a}"')
			exit(1)
		}
	}
	mut test_prefs := prefs
	mut has_fails := false
	for i, file in files_to_test {
		test_prefs.command = file
		test_prefs.out_name = '/tmp/test_${i}.js'
		test_prefs.should_run = true
		res := builder.compile(test_prefs)
		if res == 0 {
			println('OK ${file}')
		} else {
			has_fails = true
			println('FAIL ${file}')
		}
	}
	if has_fails {
		return 1
	}
	return 0
}

fun launch_tool(name string, args []string) i32 {
	tool_base_path := os.resource_abs_path(os.join_path('cli', ['tools', name]))
	tool_source := tool_base_path + '.bt'
	tool_exe := tool_base_path + '.js'
	args_string := args.join(' ')
	baitexe := os.executable()
	comp_res := os.exec('node ${baitexe} ${tool_source} -o ${tool_exe}')
	if comp_res.code != 0 {
		eprintln('Failed to compile tool "${name}" with error: ${comp_res.stderr}')
		return 1
	}
	return os.system('node ${tool_exe} ${args_string}')
}

fun main() {
	args := os.ARGS.slice(2, os.ARGS.length)
	mut prefs := preference.parse_args(args)
	prefs.set_comptime_vars()
	if TOOLS.contains(prefs.command) {
		exit(launch_tool(prefs.command, prefs.args))
	}
	match prefs.command {
		'test' {
			exit(run_tests(prefs))
		}
		'version' {
			println('Bait ${util.VERSION}')
			return
		}
	}
	if os.exists(prefs.command) {
		ensure_dir_exists(os.dir(prefs.out_name))
		exit(builder.compile(prefs))
	}
	eprintln('error: unknown file or command: "${prefs.command}"')
	exit(1)
}
